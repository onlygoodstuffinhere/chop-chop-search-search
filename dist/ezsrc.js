/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/double-metaphone/index.js":
/*!************************************************!*\
  !*** ./node_modules/double-metaphone/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* Expose. */\nmodule.exports = doubleMetaphone;\n\n/* Match vowels (including `Y`). */\nvar VOWELS = /[AEIOUY]/;\n\n/* Match few Slavo-Germanic values. */\nvar SLAVO_GERMANIC = /W|K|CZ|WITZ/;\n\n/* Match few Germanic values. */\nvar GERMANIC = /^(VAN |VON |SCH)/;\n\n/* Match initial values of which the first character\n * should be skipped. */\nvar INITIAL_EXCEPTIONS = /^(GN|KN|PN|WR|PS)/;\n\n/* Match initial Greek-like values of which the `CH`\n * sounds like `K`. */\nvar GREEK_INITIAL_CH = /^CH(IA|EM|OR([^E])|YM|ARAC|ARIS)/;\n\n/* Match Greek-like values of which the `CH` sounds\n * like `K`. */\nvar GREEK_CH = /ORCHES|ARCHIT|ORCHID/;\n\n/* Match values which when following `CH`, transform `CH`\n * to sound like `K`. */\nvar CH_FOR_KH = /[ BFHLMNRVW]/;\n\n/* Match values which when preceding a vowel and `UGH`,\n * sound like `F`. */\nvar G_FOR_F = /[CGLRT]/;\n\n/* Match initial values which sound like either `K` or `J`. */\nvar INITIAL_G_FOR_KJ = /Y[\\s\\S]|E[BILPRSY]|I[BELN]/;\n\n/* Match initial values which sound like either `K` or `J`. */\nvar INITIAL_ANGER_EXCEPTION = /^[DMR]ANGER/;\n\n/* Match values which when following `GY`, do not sound\n * like `K` or `J`. */\nvar G_FOR_KJ = /[EGIR]/;\n\n/* Match values which when following `J`, do not sound `J`. */\nvar J_FOR_J_EXCEPTION = /[LTKSNMBZ]/;\n\n/* Match values which might sound like `L`. */\nvar ALLE = /AS|OS/;\n\n/* Match Germanic values preceding `SH` which sound\n * like `S`. */\nvar H_FOR_S = /EIM|OEK|OLM|OLZ/;\n\n/* Match Dutch values following `SCH` which sound like\n * either `X` and `SK`, or `SK`. */\nvar DUTCH_SCH = /E[DMNR]|UY|OO/;\n\n/**\n * Get the phonetics according to the Double Metaphone\n * algorithm from a value.\n *\n * @param {string} value - value to detect phonetics for.\n * @return {Array.<string>} - Two phonetics.\n */\nfunction doubleMetaphone(value) {\n  var primary = '';\n  var secondary = '';\n  var index = 0;\n  var length = value.length;\n  var last = length - 1;\n  var isSlavoGermanic;\n  var isGermanic;\n  var subvalue;\n  var next;\n  var prev;\n  var nextnext;\n  var characters;\n\n  value = String(value).toUpperCase() + '     ';\n  isSlavoGermanic = SLAVO_GERMANIC.test(value);\n  isGermanic = GERMANIC.test(value);\n  characters = value.split('');\n\n  /* Skip this at beginning of word. */\n  if (INITIAL_EXCEPTIONS.test(value)) {\n    index++;\n  }\n\n  /* Initial X is pronounced Z, which maps to S. Such as `Xavier` */\n  if (characters[0] === 'X') {\n    primary += 'S';\n    secondary += 'S';\n    index++;\n  }\n\n  while (index < length) {\n    prev = characters[index - 1];\n    next = characters[index + 1];\n    nextnext = characters[index + 2];\n\n    switch (characters[index]) {\n      case 'A':\n      case 'E':\n      case 'I':\n      case 'O':\n      case 'U':\n      case 'Y':\n      case 'À':\n      case 'Ê':\n      case 'É':\n        if (index === 0) {\n          /* All initial vowels now map to `A`. */\n          primary += 'A';\n          secondary += 'A';\n        }\n\n        index++;\n\n        break;\n      case 'B':\n        primary += 'P';\n        secondary += 'P';\n\n        if (next === 'B') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'Ç':\n        primary += 'S';\n        secondary += 'S';\n        index++;\n\n        break;\n      case 'C':\n        /* Various Germanic: */\n        if (\n          prev === 'A' &&\n          next === 'H' &&\n          nextnext !== 'I' &&\n          !VOWELS.test(characters[index - 2]) &&\n          (\n            nextnext !== 'E' ||\n            (\n              subvalue = value.slice(index - 2, index + 4) &&\n              (subvalue === 'BACHER' || subvalue === 'MACHER')\n            )\n          )\n        ) {\n          primary += 'K';\n          secondary += 'K';\n          index += 2;\n\n          break;\n        }\n\n        /* Special case for `Caesar`. */\n        if (index === 0 && value.slice(index + 1, index + 6) === 'AESAR') {\n          primary += 'S';\n          secondary += 'S';\n          index += 2;\n\n          break;\n        }\n\n        /* Italian `Chianti`. */\n        if (value.slice(index + 1, index + 4) === 'HIA') {\n          primary += 'K';\n          secondary += 'K';\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'H') {\n          /* Find `Michael`. */\n          if (\n            index > 0 &&\n            nextnext === 'A' &&\n            characters[index + 3] === 'E'\n          ) {\n            primary += 'K';\n            secondary += 'X';\n            index += 2;\n\n            break;\n          }\n\n          /* Greek roots such as `chemistry`, `chorus`. */\n          if (index === 0 && GREEK_INITIAL_CH.test(value)) {\n            primary += 'K';\n            secondary += 'K';\n            index += 2;\n\n            break;\n          }\n\n          /* Germanic, Greek, or otherwise `CH` for `KH` sound. */\n          if (\n            isGermanic ||\n            /* Such as 'architect' but not 'arch', orchestra',\n             * 'orchid'. */\n            GREEK_CH.test(value.slice(index - 2, index + 4)) ||\n            (nextnext === 'T' || nextnext === 'S') ||\n            (\n                (\n                    index === 0 ||\n                    prev === 'A' ||\n                    prev === 'E' ||\n                    prev === 'O' ||\n                    prev === 'U'\n                ) &&\n                /* Such as `wachtler`, `weschsler`, but not\n                 * `tichner`. */\n                CH_FOR_KH.test(nextnext)\n            )\n          ) {\n            primary += 'K';\n            secondary += 'K';\n          } else if (index === 0) {\n            primary += 'X';\n            secondary += 'X';\n          /* Such as 'McHugh'. */\n          } else if (value.slice(0, 2) === 'MC') {\n            /* Bug? Why matching absolute? what about McHiccup? */\n            primary += 'K';\n            secondary += 'K';\n          } else {\n            primary += 'X';\n            secondary += 'K';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        /* Such as `Czerny`. */\n        if (\n          next === 'Z' &&\n          value.slice(index - 2, index) !== 'WI'\n        ) {\n          primary += 'S';\n          secondary += 'X';\n          index += 2;\n\n          break;\n        }\n\n        /* Such as `Focaccia`. */\n        if (value.slice(index + 1, index + 4) === 'CIA') {\n          primary += 'X';\n          secondary += 'X';\n          index += 3;\n\n          break;\n        }\n\n        /* Double `C`, but not `McClellan`. */\n        if (\n          next === 'C' &&\n          !(index === 1 && characters[0] === 'M')\n        ) {\n          /* Such as `Bellocchio`, but not `Bacchus`. */\n          if (\n            (\n              nextnext === 'I' ||\n              nextnext === 'E' ||\n              nextnext === 'H'\n            ) &&\n            value.slice(index + 2, index + 4) !== 'HU'\n          ) {\n            subvalue = value.slice(index - 1, index + 4);\n\n            /* Such as `Accident`, `Accede`, `Succeed`. */\n            if (\n              (index === 1 && prev === 'A') ||\n              subvalue === 'UCCEE' ||\n              subvalue === 'UCCES'\n            ) {\n              primary += 'KS';\n              secondary += 'KS';\n            /* Such as `Bacci`, `Bertucci`, other Italian. */\n            } else {\n              primary += 'X';\n              secondary += 'X';\n            }\n\n            index += 3;\n\n            break;\n          } else {\n            /* Pierce's rule. */\n            primary += 'K';\n            secondary += 'K';\n            index += 2;\n\n            break;\n          }\n        }\n\n        if (next === 'G' || next === 'K' || next === 'Q') {\n          primary += 'K';\n          secondary += 'K';\n          index += 2;\n\n          break;\n        }\n\n        /* Italian. */\n        if (\n          next === 'I' &&\n          /* Bug: The original algorithm also calls for A (as\n           * in CIA), which is already taken care of above. */\n          (nextnext === 'E' || nextnext === 'O')\n        ) {\n          primary += 'S';\n          secondary += 'X';\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'I' || next === 'E' || next === 'Y') {\n          primary += 'S';\n          secondary += 'S';\n          index += 2;\n\n          break;\n        }\n\n        primary += 'K';\n        secondary += 'K';\n\n        /* Skip two extra characters ahead in `Mac Caffrey`,\n         * `Mac Gregor`. */\n        if (\n          next === ' ' &&\n          (nextnext === 'C' || nextnext === 'G' || nextnext === 'Q')\n        ) {\n          index += 3;\n          break;\n        }\n\n        /* Bug: Already covered above.\n         *\n         * if (\n         *   next === 'K' ||\n         *   next === 'Q' ||\n         *   (next === 'C' && nextnext !== 'E' && nextnext !== 'I')\n         * ) {\n         *   index++;\n         * }\n         */\n        index++;\n\n        break;\n      case 'D':\n        if (next === 'G') {\n          /* Such as `edge`. */\n          if (nextnext === 'E' || nextnext === 'I' || nextnext === 'Y') {\n            primary += 'J';\n            secondary += 'J';\n            index += 3;\n          /* Such as `Edgar`. */\n          } else {\n            primary += 'TK';\n            secondary += 'TK';\n            index += 2;\n          }\n\n          break;\n        }\n\n        if (next === 'T' || next === 'D') {\n          primary += 'T';\n          secondary += 'T';\n          index += 2;\n\n          break;\n        }\n\n        primary += 'T';\n        secondary += 'T';\n        index++;\n\n        break;\n      case 'F':\n        if (next === 'F') {\n          index++;\n        }\n\n        index++;\n        primary += 'F';\n        secondary += 'F';\n\n        break;\n      case 'G':\n        if (next === 'H') {\n          if (index > 0 && !VOWELS.test(prev)) {\n            primary += 'K';\n            secondary += 'K';\n            index += 2;\n\n            break;\n          }\n\n          /* Such as `Ghislane`, `Ghiradelli`. */\n          if (index === 0) {\n            if (nextnext === 'I') {\n              primary += 'J';\n              secondary += 'J';\n            } else {\n              primary += 'K';\n              secondary += 'K';\n            }\n\n            index += 2;\n\n            break;\n          }\n\n          /* Parker's rule (with some further refinements). */\n          if (\n            (\n              /* Such as `Hugh`.  The comma is not a bug. */\n              subvalue = characters[index - 2],\n              subvalue === 'B' ||\n              subvalue === 'H' ||\n              subvalue === 'D'\n            ) ||\n            (\n              /* Such as `bough`.  The comma is not a bug. */\n              subvalue = characters[index - 3],\n              subvalue === 'B' ||\n              subvalue === 'H' ||\n              subvalue === 'D'\n            ) ||\n            (\n              /* Such as `Broughton`.  The comma is not a bug. */\n              subvalue = characters[index - 4],\n              subvalue === 'B' ||\n              subvalue === 'H'\n            )\n          ) {\n            index += 2;\n\n            break;\n          }\n\n          /* Such as `laugh`, `McLaughlin`, `cough`, `gough`,\n           * `rough`, `tough`. */\n          if (\n            index > 2 &&\n            prev === 'U' &&\n            G_FOR_F.test(characters[index - 3])\n          ) {\n            primary += 'F';\n            secondary += 'F';\n          } else if (index > 0 && prev !== 'I') {\n            primary += 'K';\n            secondary += 'K';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'N') {\n          if (\n            index === 1 &&\n            VOWELS.test(characters[0]) &&\n            !isSlavoGermanic\n          ) {\n            primary += 'KN';\n            secondary += 'N';\n          /* Not like `Cagney`. */\n          } else if (\n            value.slice(index + 2, index + 4) !== 'EY' &&\n            value.slice(index + 1) !== 'Y' &&\n            !isSlavoGermanic\n          ) {\n            primary += 'N';\n            secondary += 'KN';\n          } else {\n            primary += 'KN';\n            secondary += 'KN';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        /* Such as `Tagliaro`. */\n        if (\n          value.slice(index + 1, index + 3) === 'LI' &&\n          !isSlavoGermanic\n        ) {\n          primary += 'KL';\n          secondary += 'L';\n          index += 2;\n\n          break;\n        }\n\n        /* -ges-, -gep-, -gel- at beginning. */\n        if (\n          index === 0 &&\n          INITIAL_G_FOR_KJ.test(value.slice(1, 3))\n        ) {\n          primary += 'K';\n          secondary += 'J';\n          index += 2;\n\n          break;\n        }\n\n        /* -ger-, -gy-. */\n        if (\n          (\n            value.slice(index + 1, index + 3) === 'ER' &&\n            prev !== 'I' && prev !== 'E' &&\n            !INITIAL_ANGER_EXCEPTION.test(value.slice(0, 6))\n          ) ||\n          (next === 'Y' && !G_FOR_KJ.test(prev))\n        ) {\n          primary += 'K';\n          secondary += 'J';\n          index += 2;\n\n          break;\n        }\n\n        /* Italian such as `biaggi`. */\n        if (\n          next === 'E' ||\n          next === 'I' ||\n          next === 'Y' ||\n          (\n              (prev === 'A' || prev === 'O') &&\n              next === 'G' &&\n              nextnext === 'I'\n          )\n        ) {\n          /* Obvious Germanic. */\n          if (\n            value.slice(index + 1, index + 3) === 'ET' ||\n            isGermanic\n          ) {\n            primary += 'K';\n            secondary += 'K';\n          } else {\n            primary += 'J';\n\n            /* Always soft if French ending. */\n            if (value.slice(index + 1, index + 5) === 'IER ') {\n              secondary += 'J';\n            } else {\n              secondary += 'K';\n            }\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'G') {\n          index++;\n        }\n\n        index++;\n\n        primary += 'K';\n        secondary += 'K';\n\n        break;\n      case 'H':\n        /* Only keep if first & before vowel or btw. 2 vowels. */\n        if (VOWELS.test(next) && (index === 0 || VOWELS.test(prev))) {\n          primary += 'H';\n          secondary += 'H';\n\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'J':\n        /* Obvious Spanish, `jose`, `San Jacinto`. */\n        if (\n          value.slice(index, index + 4) === 'JOSE' ||\n          value.slice(0, 4) === 'SAN '\n        ) {\n          if (\n            value.slice(0, 4) === 'SAN ' ||\n            (\n              index === 0 &&\n              characters[index + 4] === ' '\n            )\n          ) {\n            primary += 'H';\n            secondary += 'H';\n          } else {\n            primary += 'J';\n            secondary += 'H';\n          }\n\n          index++;\n\n          break;\n        }\n\n        if (\n          index === 0\n          /* Bug: unreachable (see previous statement).\n           * && value.slice(index, index + 4) !== 'JOSE'. */\n        ) {\n          primary += 'J';\n\n          /* Such as `Yankelovich` or `Jankelowicz`. */\n          secondary += 'A';\n        /* Spanish pron. of such as `bajador`. */\n        } else if (\n          !isSlavoGermanic &&\n          (next === 'A' || next === 'O') &&\n          VOWELS.test(prev)\n        ) {\n          primary += 'J';\n          secondary += 'H';\n        } else if (index === last) {\n          primary += 'J';\n        } else if (\n          prev !== 'S' && prev !== 'K' && prev !== 'L' &&\n          !J_FOR_J_EXCEPTION.test(next)\n        ) {\n          primary += 'J';\n          secondary += 'J';\n        /* It could happen. */\n        } else if (next === 'J') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'K':\n        if (next === 'K') {\n          index++;\n        }\n\n        primary += 'K';\n        secondary += 'K';\n        index++;\n\n        break;\n      case 'L':\n        if (next === 'L') {\n          /* Spanish such as `cabrillo`, `gallegos`. */\n          if (\n            (\n              index === length - 3 &&\n              (\n                (prev === 'A' && nextnext === 'E') ||\n                (prev === 'I' && (nextnext === 'O' || nextnext === 'A'))\n              )\n            ) ||\n            (\n              prev === 'A' &&\n              nextnext === 'E' &&\n              (\n                (characters[last] === 'A' || characters[last] === 'O') ||\n                ALLE.test(value.slice(last - 1, length))\n              )\n            )\n          ) {\n            primary += 'L';\n            index += 2;\n\n            break;\n          }\n\n          index++;\n        }\n\n        primary += 'L';\n        secondary += 'L';\n        index++;\n\n        break;\n      case 'M':\n        if (\n          next === 'M' ||\n          /* Such as `dumb`, `thumb`. */\n          (\n            prev === 'U' &&\n            next === 'B' &&\n            (index + 1 === last || value.slice(index + 2, index + 4) === 'ER')\n          )\n        ) {\n          index++;\n        }\n\n        index++;\n        primary += 'M';\n        secondary += 'M';\n\n        break;\n      case 'N':\n        if (next === 'N') {\n          index++;\n        }\n\n        index++;\n        primary += 'N';\n        secondary += 'N';\n\n        break;\n      case 'Ñ':\n        index++;\n        primary += 'N';\n        secondary += 'N';\n\n        break;\n      case 'P':\n        if (next === 'H') {\n          primary += 'F';\n          secondary += 'F';\n          index += 2;\n\n          break;\n        }\n\n        /* Also account for `campbell` and `raspberry`. */\n        subvalue = next;\n\n        if (subvalue === 'P' || subvalue === 'B') {\n          index++;\n        }\n\n        index++;\n\n        primary += 'P';\n        secondary += 'P';\n\n        break;\n      case 'Q':\n        if (next === 'Q') {\n          index++;\n        }\n\n        index++;\n        primary += 'K';\n        secondary += 'K';\n\n        break;\n      case 'R':\n        /* French such as `Rogier`, but exclude `Hochmeier`. */\n        if (\n          index === last &&\n          !isSlavoGermanic &&\n          prev === 'E' &&\n          characters[index - 2] === 'I' &&\n          characters[index - 4] !== 'M' &&\n          (\n            characters[index - 3] !== 'E' &&\n            characters[index - 3] !== 'A'\n          )\n        ) {\n          secondary += 'R';\n        } else {\n          primary += 'R';\n          secondary += 'R';\n        }\n\n        if (next === 'R') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'S':\n        /* Special cases `island`, `isle`, `carlisle`, `carlysle`. */\n        if (next === 'L' && (prev === 'I' || prev === 'Y')) {\n          index++;\n\n          break;\n        }\n\n        /* Special case `sugar-`. */\n        if (index === 0 && value.slice(1, 5) === 'UGAR') {\n          primary += 'X';\n          secondary += 'S';\n          index++;\n\n          break;\n        }\n\n        if (next === 'H') {\n          /* Germanic. */\n          if (H_FOR_S.test(value.slice(index + 1, index + 5))) {\n            primary += 'S';\n            secondary += 'S';\n          } else {\n            primary += 'X';\n            secondary += 'X';\n          }\n\n          index += 2;\n          break;\n        }\n\n        if (\n          next === 'I' &&\n          (nextnext === 'O' || nextnext === 'A')\n          /* Bug: Already covered by previous branch\n           * || value.slice(index, index + 4) === 'SIAN' */\n        ) {\n          if (isSlavoGermanic) {\n            primary += 'S';\n            secondary += 'S';\n          } else {\n            primary += 'S';\n            secondary += 'X';\n          }\n\n          index += 3;\n\n          break;\n        }\n\n        /* German & Anglicization's, such as `Smith` match `Schmidt`,\n         * `snider` match `Schneider`. Also, -sz- in slavic language\n         * although in hungarian it is pronounced `s`. */\n        if (\n          next === 'Z' ||\n          (\n            index === 0 &&\n            (next === 'L' || next === 'M' || next === 'N' || next === 'W')\n          )\n        ) {\n          primary += 'S';\n          secondary += 'X';\n\n          if (next === 'Z') {\n            index++;\n          }\n\n          index++;\n\n          break;\n        }\n\n        if (next === 'C') {\n          /* Schlesinger's rule. */\n          if (nextnext === 'H') {\n            subvalue = value.slice(index + 3, index + 5);\n\n            /* Dutch origin, such as `school`, `schooner`. */\n            if (DUTCH_SCH.test(subvalue)) {\n              /* Such as `schermerhorn`, `schenker`. */\n              if (subvalue === 'ER' || subvalue === 'EN') {\n                primary += 'X';\n                secondary += 'SK';\n              } else {\n                primary += 'SK';\n                secondary += 'SK';\n              }\n\n              index += 3;\n\n              break;\n            }\n\n            if (\n              index === 0 &&\n              !VOWELS.test(characters[3]) &&\n              characters[3] !== 'W'\n            ) {\n              primary += 'X';\n              secondary += 'S';\n            } else {\n              primary += 'X';\n              secondary += 'X';\n            }\n\n            index += 3;\n\n            break;\n          }\n\n          if (\n            nextnext === 'I' ||\n            nextnext === 'E' ||\n            nextnext === 'Y'\n          ) {\n            primary += 'S';\n            secondary += 'S';\n            index += 3;\n            break;\n          }\n\n          primary += 'SK';\n          secondary += 'SK';\n          index += 3;\n\n          break;\n        }\n\n        subvalue = value.slice(index - 2, index);\n\n        /* French such as `resnais`, `artois`. */\n        if (\n          index === last &&\n          (subvalue === 'AI' || subvalue === 'OI')\n        ) {\n          secondary += 'S';\n        } else {\n          primary += 'S';\n          secondary += 'S';\n        }\n\n        if (\n          next === 'S'\n          /* Bug: already taken care of by `German &\n           * Anglicization's` above:\n           * || next === 'Z' */\n        ) {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'T':\n        if (\n          next === 'I' &&\n          nextnext === 'O' &&\n          characters[index + 3] === 'N'\n        ) {\n          primary += 'X';\n          secondary += 'X';\n          index += 3;\n\n          break;\n        }\n\n        subvalue = value.slice(index + 1, index + 3);\n\n        if (\n          (next === 'I' && nextnext === 'A') ||\n          (next === 'C' && nextnext === 'H')\n        ) {\n          primary += 'X';\n          secondary += 'X';\n          index += 3;\n\n          break;\n        }\n\n        if (next === 'H' || (next === 'T' && nextnext === 'H')) {\n          /* Special case `Thomas`, `Thames` or Germanic. */\n          if (\n            isGermanic ||\n            (\n              (nextnext === 'O' || nextnext === 'A') &&\n              characters[index + 3] === 'M'\n            )\n          ) {\n            primary += 'T';\n            secondary += 'T';\n          } else {\n            primary += '0';\n            secondary += 'T';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'T' || next === 'D') {\n          index++;\n        }\n\n        index++;\n        primary += 'T';\n        secondary += 'T';\n\n        break;\n      case 'V':\n        if (next === 'V') {\n          index++;\n        }\n\n        primary += 'F';\n        secondary += 'F';\n        index++;\n\n        break;\n      case 'W':\n        /* Can also be in middle of word (as already taken care of\n         * for initial). */\n        if (next === 'R') {\n          primary += 'R';\n          secondary += 'R';\n          index += 2;\n\n          break;\n        }\n\n        if (index === 0) {\n          /* `Wasserman` should match `Vasserman`. */\n          if (VOWELS.test(next)) {\n            primary += 'A';\n            secondary += 'F';\n          } else if (next === 'H') {\n            /* Need `Uomo` to match `Womo`. */\n            primary += 'A';\n            secondary += 'A';\n          }\n        }\n\n        /* `Arnow` should match `Arnoff`. */\n        if (\n          (\n            (prev === 'E' || prev === 'O') &&\n            next === 'S' &&\n            nextnext === 'K' &&\n            (\n              characters[index + 3] === 'I' ||\n              characters[index + 3] === 'Y'\n            )\n          ) ||\n          /* Maybe a bug? Shouldn't this be general Germanic? */\n          value.slice(0, 3) === 'SCH' ||\n          (index === last && VOWELS.test(prev))\n        ) {\n          secondary += 'F';\n          index++;\n\n          break;\n        }\n\n        /* Polish such as `Filipowicz`. */\n        if (\n          next === 'I' &&\n          (nextnext === 'C' || nextnext === 'T') &&\n          characters[index + 3] === 'Z'\n        ) {\n          primary += 'TS';\n          secondary += 'FX';\n          index += 4;\n\n          break;\n        }\n\n        index++;\n\n        break;\n      case 'X':\n        /* French such as `breaux`. */\n        if (\n          !(\n            index === last &&\n            (\n              /* Bug: IAU and EAU also match by AU\n               * (/IAU|EAU/.test(value.slice(index - 3, index))) || */\n              (\n                prev === 'U' &&\n                (characters[index - 2] === 'A' || characters[index - 2] === 'O')\n              )\n            )\n          )\n        ) {\n          primary += 'KS';\n          secondary += 'KS';\n        }\n\n        if (next === 'C' || next === 'X') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'Z':\n        /* Chinese pinyin such as `Zhao`. */\n        if (next === 'H') {\n          primary += 'J';\n          secondary += 'J';\n          index += 2;\n\n          break;\n        } else if (\n          (\n            next === 'Z' &&\n            (nextnext === 'A' || nextnext === 'I' || nextnext === 'O')\n          ) ||\n          (isSlavoGermanic && index > 0 && prev !== 'T')\n        ) {\n          primary += 'S';\n          secondary += 'TS';\n        } else {\n          primary += 'S';\n          secondary += 'S';\n        }\n\n        if (next === 'Z') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      default:\n        index++;\n    }\n  }\n\n  return [primary, secondary];\n}\n\n\n//# sourceURL=webpack:///./node_modules/double-metaphone/index.js?");

/***/ }),

/***/ "./node_modules/fast-levenshtein/levenshtein.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-levenshtein/levenshtein.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n  'use strict';\n  \n  var collator;\n  try {\n    collator = (typeof Intl !== \"undefined\" && typeof Intl.Collator !== \"undefined\") ? Intl.Collator(\"generic\", { sensitivity: \"base\" }) : null;\n  } catch (err){\n    console.log(\"Collator could not be initialized and wouldn't be used\");\n  }\n  // arrays to re-use\n  var prevRow = [],\n    str2Char = [];\n  \n  /**\n   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\n   */\n  var Levenshtein = {\n    /**\n     * Calculate levenshtein distance of the two strings.\n     *\n     * @param str1 String the first string.\n     * @param str2 String the second string.\n     * @param [options] Additional options.\n     * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.\n     * @return Integer the levenshtein distance (0 and above).\n     */\n    get: function(str1, str2, options) {\n      var useCollator = (options && collator && options.useCollator);\n      \n      var str1Len = str1.length,\n        str2Len = str2.length;\n      \n      // base cases\n      if (str1Len === 0) return str2Len;\n      if (str2Len === 0) return str1Len;\n\n      // two rows\n      var curCol, nextCol, i, j, tmp;\n\n      // initialise previous row\n      for (i=0; i<str2Len; ++i) {\n        prevRow[i] = i;\n        str2Char[i] = str2.charCodeAt(i);\n      }\n      prevRow[str2Len] = str2Len;\n\n      var strCmp;\n      if (useCollator) {\n        // calculate current row distance from previous row using collator\n        for (i = 0; i < str1Len; ++i) {\n          nextCol = i + 1;\n\n          for (j = 0; j < str2Len; ++j) {\n            curCol = nextCol;\n\n            // substution\n            strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));\n\n            nextCol = prevRow[j] + (strCmp ? 0 : 1);\n\n            // insertion\n            tmp = curCol + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n            // deletion\n            tmp = prevRow[j + 1] + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n\n            // copy current col value into previous (in preparation for next iteration)\n            prevRow[j] = curCol;\n          }\n\n          // copy last col value into previous (in preparation for next iteration)\n          prevRow[j] = nextCol;\n        }\n      }\n      else {\n        // calculate current row distance from previous row without collator\n        for (i = 0; i < str1Len; ++i) {\n          nextCol = i + 1;\n\n          for (j = 0; j < str2Len; ++j) {\n            curCol = nextCol;\n\n            // substution\n            strCmp = str1.charCodeAt(i) === str2Char[j];\n\n            nextCol = prevRow[j] + (strCmp ? 0 : 1);\n\n            // insertion\n            tmp = curCol + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n            // deletion\n            tmp = prevRow[j + 1] + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n\n            // copy current col value into previous (in preparation for next iteration)\n            prevRow[j] = curCol;\n          }\n\n          // copy last col value into previous (in preparation for next iteration)\n          prevRow[j] = nextCol;\n        }\n      }\n      return nextCol;\n    }\n\n  };\n\n  // amd\n  if (\"function\" !== \"undefined\" && __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") !== null && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Levenshtein;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // commonjs\n  else if (typeof module !== \"undefined\" && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\n    module.exports = Levenshtein;\n  }\n  // web worker\n  else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\n    self.Levenshtein = Levenshtein;\n  }\n  // browser main thread\n  else if (typeof window !== \"undefined\" && window !== null) {\n    window.Levenshtein = Levenshtein;\n  }\n}());\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/fast-levenshtein/levenshtein.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/bookmarks.js":
/*!**************************!*\
  !*** ./src/bookmarks.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ \"./src/settings.js\");\n/* ---------------------------------------------------------------------\n  Fetch bookmarks on install, get new bookmarks, get deleted bookmarks\n-----------------------------------------------------------------------*/\n//import md5 from 'blueimp-md5';\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    /*\n      Returns map of all bookmarks\n      bookmark is an object like this :\n      {\n\t\"type\": \"bookmark\",\n\t\"title\": <string>,\n\t\"url\": <string>,\n\t\"date\": <int>,\n\t\"id\": <string>\t\n\t}\n      @return : Map[id,bookmark]\n    */\n    getAll : async function getAll(){\n\tlet settings = await _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get();\n\tif (settings.indexBm ){\n\t    try{\n\t\tconst bmRootArray = await browser.bookmarks.getTree();\n\t\tlet bmRoot = bmRootArray[0];\n\t\tlet result = walkBmTree(bmRoot);\n\t\treturn result;\n\t    }\n\t    catch(err){\n\t\tconsole.log(`Failed to get bookmarks : ${err}`);\n\t\treturn new Map();\n\t    }\n\t}\n\telse{\n\t    return new Map();\n\t}\n    },\n    /*\n      Registers callbacks for bookmark creation, deletion (and modification, comming soon) events\n     */\n    init : function(){\n\tbrowser.bookmarks.onCreated.addListener(indexBm);\n\tbrowser.bookmarks.onRemoved.addListener(disindexBm);\n\t//browser.bookmarks.onChanged.addListener(); //TODO \n    }\n\n});\n\n/*\n  Called recursively to go through bookmark tree,\n  returns map[id, bookmark]\n*/\nfunction walkBmTree ( bmNode ) {\n    let bmMap = new Map();\n    if ( bmNode.type === \"folder\" ) {\n\tfor( let bmChild of bmNode.children ){\n            //bmList = bmList.concat(walkBmTree(bmChild));\n\t    for ( var [k,v] of walkBmTree(bmChild)){\n\t\tbmMap.set(k,v);\n\t    }\n\t}\n    }\n    else if ( bmNode.type === \"bookmark\" && bmNode.url.startsWith(\"http\")){\n\tlet bm = bmNodeToBm(bmNode);\n\tbmMap.set(bm.id,bm);\n    }\n    return bmMap;\n}\n\n/*function getBmId ( url, title ){\n    return md5 ( url + title );\n}*/\n\n/*\n  Handles bookmark creation events :\n  Parses ff bookmark, calls index script to index bm\n  if settings allow bookmark indexing\n*/\nfunction indexBm(id, bookmark){\n    _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get().then(function (settings){\n\tif ( settings.indexBm ) {\n\t    let bm = bmNodeToBm(bookmark);\n\t    let bmMap = new Map();\n\t    bmMap.set(bm.id,bm);\n\t    _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].index(bmMap);\n\t}\t\n    });\n}\n\n/*\n  Handles bookmark deletion event\n  Calls index script to disindex bm\n*/\nfunction disindexBm(id, info){\n    let bmId = \"bm_\"+id;\n    _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].disindex(bmId);\n}\n\n/*\n  Parses browser bookmark object\n*/\nfunction bmNodeToBm( bmNode ){\n    return {\n\t\"type\": \"bookmark\", //we need to diferentiate bookmarks and other indexed pages\n\t                    // like history\n\t\"title\": bmNode.title,\n\t\"url\": bmNode.url,\n\t\"date\": bmNode.dateAdded,\n\t\"id\": \"bm_\"+bmNode.id\t\n    };\n}\n\n\n//# sourceURL=webpack:///./src/bookmarks.js?");

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.js */ \"./src/settings.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/*\n  Get browsing history and index it\n*/\n\n\n\nvar incompletePages = new Map();\nvar sessionStart;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    /*\n      Returns map of browsing history pages according to parameters\n      defined in the settings.\n\n      Pages are objects like this :\n      {\n\t\"type\": \"history\",\n\t\"title\": <string>,\n\t\"url\": <string>,\n\t\"date\": <int>,\n\t\"id\": <string>,\n\t\"visitCount\": <int>\n\t}\n      @return : Map[id,page]\n     */\n    getAll: loadHistory,\n    /*\n      Register handlers for history updates\n     */\n    init: function (){\n\tbrowser.history.onVisited.addListener(handleVisited);\n\tbrowser.history.onVisitRemoved.addListener(handleRemoved);\n\tbrowser.history.onTitleChanged.addListener(handleTitleChanged);\n    },\n    filterByDate: filterHistoryByDaterange,\n    getSession: getSessionDate,\n    setSession: setSessionDate\n});\n\nfunction getSessionDate(){\n    return sessionStart;\n}\n\nfunction setSessionDate( date ){\n    sessionStart = date;\n}\n\nasync function loadHistory(){\n    // get settings to decide what pages to fetch\n    let settings = await _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get();\n    if ( settings.indexHistory === true ) { //only get history if enabled in settings\n\tlet dateRange = settings.historyDuration; //<\"forever\"/\"7d\"/\"24h\"/\"session\">\n\tlet startDate;\n\tlet endDate = new Date();\n\t//javascript date is timestamp in millis\n\tswitch(dateRange){\n\tcase \"forever\":{\n\t    startDate = new Date('August 19, 1975 23:15:30');;\n\t    break;\n\t}\n\tcase \"7d\":{\n\t    startDate = new Date();\n\t    startDate = startDate - 604800000;\n\t    break;\n\t}\n\tcase \"24h\":{\n\t    startDate = new Date();\n\t    startDate = startDate - 86400000;\n\t    break;\n\t}\n\tcase \"session\":{\n\t    //TODO: record session start time\n\t    //console.log(\"TODO : keep track of session time\");\n\t    startDate = sessionStart;//new Date('August 19, 1975 23:15:30');\n\t    break;\n\t}\n\t}\n\t\n\tlet query = {\n\t    \"text\": \"\", //empty string gets all the bookmarks\n\t    \"startTime\": startDate,\n\t    \"endTime\": endDate,\n\t    \"maxResults\": Number.MAX_SAFE_INTEGER\n\t};\n\t\n\tlet history = await browser.history.search(query);\n\tlet pageMap = new Map();\n\tfor (let p of history ){\n\t    if ( filterHistoryItem(p) ){\n\t\tlet parsedPage = parseHistoryItem(p);\n\t\tpageMap.set(parsedPage.id, parsedPage);\n\t    }\n\t}\n\treturn pageMap;\n    }\n    else{// settings says we don't use browsing history\n\treturn new Map();\n    }\n}\n\nfunction parseHistoryItem(historyItem){\n    return {\n\ttitle: historyItem.title,\n\turl: historyItem.url,\n\ttype: \"history\",\n\tid: \"his_\"+historyItem.id,\n\tvisitCount: historyItem.visitCount,\n\tdate: historyItem.lastVisitTime\n    };\n}\n\nfunction filterHistoryItem(historyItem){\n    return historyItem.url.startsWith(\"http\");\n}\n\nfunction handleVisited(historyItem){\n    if ( historyItem.title === \"\" ){ \n\t/*\n\t  Title should be empty at first, if so store page here until we get \n\t  its full information.\n\t*/\n\tincompletePages.set(historyItem.url, parseHistoryItem(historyItem));\n    }\n    else{\n\tindexHistory(parseHistoryItem(historyItem));\n    }\n}\n\n/*\n  Called when history gets deleted\n  Param will eiher have allHistory to true and no urls or\n  have allHistory to false and urls of deleted browsing history.\n  @param{\n  \"urls\": [<string>],\n  \"allHistory\": boolean\n  }\n*/\nfunction handleRemoved (deleted) {\n    if ( deleted.allHistory ){\n\t//no urls, we just remove all browsing history\n\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].disindexByType(\"history\");\n    }\n    else{\n\t//remove urls in array\n\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getAllByType(\"history\").then(function(allHist){\n\t    let idArray = [];\n\t    for( let historyItem of allHist ){\n\t\tif ( deleted.urls.includes(historyItem.url) ){\n\t\t    idArray.push(historyItem.id);\n\t\t}\n\t    }\n\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].disindex(idArray);\n\t});\n    }\n}\n\n/*\n  Gets called when freshly visited page loads its title\n  @param {\n  \"title\": <string>,\n  \"url\": <string>\n  }\n*/\nfunction handleTitleChanged(changedObj){\n    if ( incompletePages.has(changedObj.url) ){\n\tlet histObj = incompletePages.get(changedObj.url);\n\thistObj.title = changedObj.title;\n\tindexHistory(histObj);\n    }\n    return;\n}\n\nfunction indexHistory (historyItem ){\n    if ( ! filterHistoryItem(historyItem) ){\n\treturn;\n    }\n    \n    _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get().then(function(settings){\n\tif ( settings.indexHistory === true ){\n\t    let toIndex = new Map();\n\t    toIndex.set(historyItem.id, historyItem);\n\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(toIndex);\n\t}\n    });\n} \n\n/*\n  Returns history item ids to remove based off date range\n  date range one of : <\"forever\"/\"7d\"/\"24h\"/\"session\">\n*/\n\nfunction filterHistoryByDaterange(historyArray, dateRange){\n    if ( dateRange === \"forever\"){\n\treturn [];\n    }\n    let results = [];\n    let now = new Date();\n    for ( let hist of historyArray ){\n\tswitch (dateRange) {\n\tcase \"7d\":{\n\t    if( (now - hist.date ) > 604800000 ){\n\t\tresults.push(hist.id);\n\t    }\n\t    break;\n\t}\n\tcase \"24h\": {\n\t    if( (now - hist.date ) > 86400000 ){\n\t\tresults.push(hist.id);\n\t    }\n\t    break;\n\t}\n\tcase \"session\": {\n\t    if( (now - hist.date ) > ( now - sessionStart ) ){\n\t\tresults.push(hist.id);\n\t    }\n\t    break;\n\t}\n\t}\n    }\n    return results;\n}\n\n\n//# sourceURL=webpack:///./src/history.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stringUtils.js */ \"./src/stringUtils.js\");\n/* harmony import */ var _storageDao_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storageDao.js */ \"./src/storageDao.js\");\n\n\n\n//var index = new Map();\n//var bmMap = new Map();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    /*\n      Index pages \n      \n     */\n    index : indexPages,\n    \n    /*\n      Get array of page ids from an index token or array of tokens\n     */\n    getPageIds : getPagesIds,\n\n    /*\n      Get array of bookmarks from a bookmark id or array of ids\n     */\n    getPages : getPages,\n\n    /*\n      Disindex pages, either takes array of ids or a single id\n     */\n    disindex : remove,\n    disindexByType : removeByType,\n    getAllByType : findByType\n});\n\n\n/*\n  Returns array of all pages by their type <bookmark/history>\n*/\nasync function findByType( type ){\n    let allPages = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getAll(\"page\");\n    let result = [];\n    for ( let page of allPages ){\n\tif ( page.val.type === type ){\n\t    result.push(page.val);\n\t}\n    }\n    return result;\n}\n\n/*\n  Remove pages from the index based on their type\n  (bookmark / history )\n*/\nasync function removeByType( type ){\n    let allPages = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getAll(\"page\");\n    let idArray = [];\n    for ( let page of allPages ){\n\tif (page.val.type === type ){\n\t    idArray.push(page.val.id);\n\t}\n    }\n    await remove(idArray);\n}\n\n/*\n  Remove a page or pages from the index\n  @param and id or array of ids\n*/\nasync function remove( pageId ) {\n    //remove page ids from pageid - page index\n    if ( Array.isArray(pageId) ){\n\tfor (let id of pageId ) {\n\t    let hasPage = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"page\", id);\n\t    if ( hasPage === true ){\n\t\t_storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].del(\"page\", id);\n\t    }\n\t}\n    }\n    else{\n\tlet hasPage = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"page\", pageId);\n\tif ( hasPage === true ){\n\t    _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].del(\"page\", pageId);\n\t}\n    }\n\t\n    // get full index ( token - array[pageId] )\n    // remove references to pageId\n    let indexArray = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getAll(\"index\");\n    for ( let indexItem of indexArray ) {\n\tif( Array.isArray(pageId)){\n\t    for ( let id of pageId ){\n\t\tlet i = indexItem.val.indexOf(id);\n\t\tif (  i !== -1 ){\n\t\t    indexItem.val = indexItem.val.splice ( i, 1 );\n\t\t    if ( indexItem.val.lenth > 0){\n\t\t\t_storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"index\", indexItem.id, indexItem.val);\n\t\t    }\n\t\t    else{\n\t\t\t_storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].del(\"index\", indexItem.id );\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse{\n\t    let i = indexItem.val.indexOf(pageId);\n\t    if (  i !== -1 ){\n\t\tindexItem.val = indexItem.val.splice ( i, 1 );\n\t\tif ( indexItem.val.lenth > 0){\n\t\t    _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"index\", indexItem.id, indexItem.val);\n\t\t}\n\t\telse{\n\t\t    _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].del(\"index\", indexItem.id );\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n  Index pages to make them available to search\n  @param : pages\n           Map [ id, page], page being an object : \n\n      {\n\t\"type\": <\"bookmark\"/\"history\">,\n\t\"title\": <string>,\n\t\"url\": <string>,\n\t\"date\": <int>,\n\t\"id\": <string>\t\n\t}\n*/\nasync function indexPages( pages ){\n    pages.forEach(async function (v,k ){\n\tlet hasPage = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"page\", k);\n\t// store page in pageId - page index\n\t// update if already there (updates visit count and last visit date\n\t// on history items)\n\tawait _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"page\", k, v);\n\tif ( hasPage === false ){\n\t    // generate search index tokens\n\t    let prefixedIndexes = [];\n\t    prefixedIndexes = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toIndexable(v.title);\n\t    prefixedIndexes = prefixedIndexes.concat(_stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].urlToIndexable(v.url));\n\t    prefixedIndexes = Array.from(new Set(prefixedIndexes)); //remove dupes\n\t    // update search index (search token - array [page id])\n\t    for ( let t of prefixedIndexes ) {\n\t\tlet hasToken = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"index\",t);\n\t\tif ( hasToken === true ){\n\t\t    let ids = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"index\", t);\n\t\t    ids.push(k);\n\t\t    await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"index\", t, ids);\n\t\t}\n\t\telse{\n\t\t    let keyArray = [\"\"+k];\n\t\t    await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"index\", t, keyArray);\n\t\t}\n\t    }\n\t}\n    });\n}\n\t\t     \n/*\n  Get page ids from search token\n  by hitting  <search token - array[page id]> index\n  @param key : string or array of strings\n  @returns : array of page ids\n*/\nasync function getPagesIds ( key ){\n    let result = [];\n    // array of tokens\n    if ( key.constructor === Array ){\n\tfor ( const k of key ){\n\t    let ids = await tokenToPageIds(k);\n\t    result = result.concat(ids);\n\t}\n    }\n    // single token\n    else{\n\tlet ids = await tokenToPageIds (key);\n\tresult = result.concat(ids);\n    }\n    return result;\n}\n\nasync function tokenToPageIds ( token ){\n    let result = [];\n    let hasToken = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"index\", token);\n    if ( hasToken === true ){\n\tlet ids = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"index\", token);\n\tresult = result.concat(ids);\n    }\n    return result;\n}\n\n/*\n  Get page from page id\n  @param : pageId string or array of string\n  @return : array of pages\n*/\nasync function getPages ( pageId ) {\n    let result = [];\n    // array of ids\n    if( pageId.constructor === Array ){\n\tfor ( const id of pageId ) {\n\t    let pages = await getPagesFromId( id );\n\t    result = result.concat(pages);\n\t}\n    }\n    // single id\n    else{\n\tlet pages = await getPagesFromId( pageId );\n\tresult = result.concat(pages);\n    }\n    return result;\n}\n\nasync function getPagesFromId(pageId){\n    let result = [];\n    let hasPage = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"page\", pageId);\n    if ( hasPage === true ){\n\tlet page = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"page\", pageId);\n\tresult.push(page);\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bookmarks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bookmarks.js */ \"./src/bookmarks.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/* harmony import */ var _omnibox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./omnibox.js */ \"./src/omnibox.js\");\n/* harmony import */ var _storageDao_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storageDao.js */ \"./src/storageDao.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./settings.js */ \"./src/settings.js\");\n/* harmony import */ var _history_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./history.js */ \"./src/history.js\");\n/* harmony import */ var _tabs_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tabs.js */ \"./src/tabs.js\");\n\n\n\n\n\n\n\n\n\n//1. setup stuf on install\n\nbrowser.runtime.onInstalled.addListener(loadBrowsingData);\n\n_settings_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].init();\n\n//2. init omnibox\n_omnibox_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].init();\n\n//3. init bookmark handlers\n_bookmarks_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].init();\n//init session time\n_history_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setSession(new Date());\n_history_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].init();\n\n_tabs_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].init();\n\n//4. clear storage\n_storageDao_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].init();\n//index.disindexByType(\"tab\"); //enable this once we start to persist storage\n\nfunction loadBrowsingData(){\n    _bookmarks_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAll().then(\n\tfunction(bms){\n\t    //1 : index bms\n\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(bms);\n\t}\n    );\n    //TODO only do this loading stuff if data is not in storage\n    // validate freshness of bms\n    _history_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].getAll().then(\n\tfunction(pageMap){\n\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(pageMap);\n\t}\n    );\n\n    _tabs_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].getAll().then(function(tabs){\n\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(tabs);\n    });\n}\n\n//TODO : delet\n_tabs_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].getAll();\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/omnibox.js":
/*!************************!*\
  !*** ./src/omnibox.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _search_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./search.js */ \"./src/search.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    init : function (){\n\tbrowser.omnibox.onInputChanged.addListener(srcInputListener);\n\tbrowser.omnibox.onInputEntered.addListener(inputEntered);\n\tbrowser.omnibox.setDefaultSuggestion(\n\t    { \"description\": \"CHOP CHOP'S SEARCH SEARCH - type at least 3 characters\" }\n\t);\n    }\n\n});\n\nfunction inputEntered(url, disposition){\n    switch (disposition) {\n    case \"currentTab\":\n\t//browser.tabs.update({url});\n\topenTab(url, true);\n\tbreak;\n    case \"newForegroundTab\":\n\t//browser.tabs.create({url});\n\topenTab(url, true);\n\tbreak;\n    case \"newBackgroundTab\":\n\t//browser.tabs.create({url, active: false});\n\topenTab(url, false);\n\tbreak;\n    }\n}\n\nfunction openTab ( url, active ){\n    browser.tabs.query({\"url\": url}).then(function(openedTabs){\n\tif ( openedTabs.length > 0 ){\n\t    let tabId = openedTabs[0].id;\n\t    browser.tabs.update(tabId, {\n\t\t\"active\": true\n\t    });\n\t}\n\telse{\n\t    browser.tabs.create({url, active: active});\n\t}\n    });\n}\n\nfunction emptySuggestion(){\n    return {\n\t\"content\": \"\",\n\t\"description\": \"Sry, no results. Please type at lest 3 characters.\"\n    };\n}\nfunction srcInputListener(text, suggest){\n    if ( text.length < 3 ) {\n\tsuggest(emptySuggestion());\n\treturn ;\n    }\n    _search_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].queryToPages(text).then(function(results){\n\tlet suggestions = results.map(function (page) {\n\t    return {\n\t\t\"content\": page.url,\n\t\t\"description\": page.title\n\t    };\n\t});\n\tif( suggestions.length === 0 ){\n\t    suggest(emptySuggestion());\n\t    return;\n\t}\n\tsuggest(suggestions);\n    });\n}\n\n\n//# sourceURL=webpack:///./src/omnibox.js?");

/***/ }),

/***/ "./src/search.js":
/*!***********************!*\
  !*** ./src/search.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stringUtils.js */ \"./src/stringUtils.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n\n\n\nvar levenshteinTreshold = 0.85;\n\n//TODO : fix this, have it make sense\nvar scoreMults = {\n    \"history\": 1.2,\n    \"bookmark\": 1.5\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    queryToPages: async function( query ){\n\tlet srcIndices = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toSearchable(query);\n\tlet pageIds = await _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getPageIds(srcIndices);\n\tlet pages = await _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getPages(pageIds);\t\n\tpages = Array.from(new Set(pages)); //remove dupes\n\tconsole.log(\"unsorted result pages :\");\n\tconsole.log(pages);\n\tpages = sortPages(pages, query);\n\treturn pages;\n    }\n});\n\nfunction sortPages(pageResults, query){\n    console.log(\"******** QUERY ********\");\n    console.log(query);\n    let compQuery = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toComparable(query);\n    //let scoredPages = [];\n    // url - array of scored pages\n    let urlScoredPageMap = new Map();\n\n    \n    pageResults.forEach(function (page){\n\tlet compPage = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toComparable(page.title);\n\n\tlet urlTokens = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].urlToTokens(page.url);\n\turlTokens.forEach(function (tk){\n\t    compPage = compPage.concat(_stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toComparable(tk));\n\t});\n\tcompPage = Array.from(new Set(compPage));\n\t\n\tlet hitScore = 0;\n\tfor ( let tk of compQuery){\n\t    for (let bt of compPage ){\n\t\tlet gScore = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].levenshtein(tk,bt);\n\t\tif ( gScore >= levenshteinTreshold ) {\n\t\t    hitScore ++;\n\t\t}\n\t    }\n\t}\n\tif ( hitScore <= 0 ){\n\t    return;\n\t}\n\thitScore = hitScore * scorePonderation(page);\n\tlet sPageArray = [];\n\tif ( urlScoredPageMap.has(page.url)){\n\t    sPageArray = urlScoredPageMap.get(page.url);\n\t}\n\tsPageArray.push({\n\t\t\"score\": hitScore,\n\t\t\"item\": page\n\t    });\n\turlScoredPageMap.set(page.url, sPageArray);\n    });\n\n    let scoredPages = aggregateScoredPages(urlScoredPageMap);\n    \n    //scoredPages = scoredPages.filter(r => r.score > 0);\n    scoredPages.sort(compareScoredPages);\n    console.log(\"scored pages\");\n    console.log(scoredPages);\n    let result = scoredPages.map(function ( sb ){\n\treturn sb.item;\n    });\n    return result;\n}\n\nfunction scorePonderation ( page ){ //TODO: fix this and have scoring system that makes sense :)\n    let p = scoreMults[page.type];\n    if ( page.type === \"history\" ){\n\tp = Math.pow(p, page.visitCount);\n    }\n    return p;\n} \n\n/*\n  Aggregates page scores for pages figuring as result from different sources\n  ( bookmarks, history and opened tabs )\n  @param : url - array of scored pages\n  @return : array of scored pages\n*/\nfunction aggregateScoredPages(urlScoredPageMap){\n    let result = [];\n    urlScoredPageMap.forEach(function(pageArray, url){\n\t//TODO: tune this\n\tlet aggregatedScoredPage = {\n\t    \"item\": pageArray[0].item,\n\t    \"score\": 0\n\t};\n\tif ( pageArray.length > 1) {\n\t    aggregatedScoredPage.item.type = \"aggregated\";\n\t}\n\tfor ( let sPage of pageArray ){\n\t    aggregatedScoredPage.score += sPage.score;\n\t}\n\tresult.push(aggregatedScoredPage);\n    });\n    return result;\n}\n\n\nfunction compareScoredPages(scoredPageA, scoredPageB ){ // TODO : take type of page into account\n                                                        // like bookmarks > history\n    //sort by score, then by most recent\n    if ( scoredPageA.score > scoredPageB.score ){\n\treturn -1;\n    }\n    else if ( scoredPageA.score < scoredPageB.score ){\n\treturn 1;\n    }\n    else if ( scoredPageA.score === scoredPageB.score ){\n\tif ( scoredPageA.date > scoredPageB.date ){\n\t    return -1;\n\t}\n\telse{\n\t    return 1;\n\t}\n    }\n    else{\n\treturn 0;\n    }\n\t\n}\n\n\n//# sourceURL=webpack:///./src/search.js?");

/***/ }),

/***/ "./src/settings.js":
/*!*************************!*\
  !*** ./src/settings.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _storageDao_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storageDao.js */ \"./src/storageDao.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/* harmony import */ var _bookmarks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bookmarks.js */ \"./src/bookmarks.js\");\n/* harmony import */ var _history_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./history.js */ \"./src/history.js\");\n/* harmony import */ var _tabs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tabs.js */ \"./src/tabs.js\");\n/*\n  Handles settings, saves them in localstorage, displays them on settings page.\n  Settings object : \n\n  {\n    \"indexBm\" : <true/false>,\n    \"indexHistory\": <true/false>,\n    \"historyDuration\": <\"forever\"/\"7d\"/\"24h\"/\"session\">\n  }\n*/\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    init: function(){\n\tbrowser.runtime.onMessage.addListener(handleMsg);\n    },\n    get: getSettings\n});\n\nfunction handleMsg ( message, sender, sendResponse ){\n    let cmd = message.cmd;\n    switch ( cmd ){\n    case \"set-settings\": {\n\tsetSettings(message.settings);\n\tsendResponse({});\n\tbreak;\n    }\n    case \"get-settings\":{\n\tgetSettings().then(function(settings){\n\t    sendResponse(settings);\n\t});\n\tbreak;\n    }\n    }\n    return true;\n}\n\nasync function getSettings(){\n    let settings = await _storageDao_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"settings\", \"settings\");\n    if ( settings == undefined ){\n\tlet defaultSettings = {\n\t    \"indexBm\" : true,\n\t    \"indexHistory\": true,\n\t    \"indexTabs\": true,\n\t    \"historyDuration\": \"forever\"\n\t};\n\treturn defaultSettings;\n    }\n    else{\n\treturn settings;\n    }\n}\n\nfunction setSettings(settings){\n    // trigger reindexing and purging of pages\n    getSettings().then(function (oldSettings) {\n\t// persist new settings first because indexing logic\n\t// looks at settings again to know wether to persist stuff\n\t// or not :/\n\t_storageDao_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].set(\"settings\", \"settings\", settings).then(function(){\n\t    //compare old settings to new settings\n\t    if ( oldSettings.indexBm !== settings.indexBm ){\n\t\tif ( settings.indexBm ){\n\t\t    //index bookmarks\n\t\t    _bookmarks_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getAll().then(function (bms){\n\t\t\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(bms);\n\t\t    });\n\t\t}\n\t\telse{\n\t\t    //disindex bookmarks\n\t\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].disindexByType(\"bookmark\");\n\t\t}\n\t    }\n\t    if ( oldSettings.indexTabs !== settings.indexTabs ){\n\t\tif ( settings.indexTabs ){\n\t\t    //TODO\n\t\t    _tabs_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getAll().then(function(tbs){\n\t\t\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(tbs);\n\t\t    });\n\t\t}\n\t\telse{\n\t\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].disindexByType(\"tab\");\n\t\t}\n\t    } \n\t    if ( oldSettings.indexHistory !== settings.indexHistory ){\n\t\tif ( settings.indexHistory ){\n\t\t    //index history\n\t\t    _history_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAll().then(function(hist){\n\t\t\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(hist);\n\t\t    });\n\t\t}\n\t\telse{\n\t\t    //disindex history\n\t\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].disindexByType(\"history\");\n\t\t}\n\t    }\n\t    else if (settings.indexHistory &&\n\t\t     ( oldSettings.historyDuration !== settings.historyDuration ) ){\n\t\t// disindex relevant parts of browsing history\n\t\t_history_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAll().then(function(hist){\n\t\t    // index history, in case new settings allow for more pages\n\t\t    // ( will look at settings and not index wrong stuff so it's cool)\n\t\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(hist);\n\t\t    // remove history items that's out of range\n\t\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getAllByType(\"history\").then(function(hist){\n\t\t\t//get history item ids to remove\n\t\t\tlet idsToDel = _history_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].filterByDate(hist, settings.historyDuration );\n\t\t\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].disindex(idsToDel);\n\t\t    });\n\t\t});\n\t\t\n\t    }\n\t});\n\t \n    });\n}\n\n\n//# sourceURL=webpack:///./src/settings.js?");

/***/ }),

/***/ "./src/storageDao.js":
/*!***************************!*\
  !*** ./src/storageDao.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*\n  Store and retrieve stuff in extension localstorage\n*/\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    set: store,\n    get: retrieve,\n    del: remove,\n    init: setup, //TODO: delete if no need for this\n    has: contains,\n    getAll: findAll\n});\n\nasync function store( type, key, val){\n    let k = String.raw`${type}.${key}`;\n    let data = {};\n    data[k] = val;\n    await browser.storage.local.set(data);\n}\nasync function retrieve ( type, key){\n    let k = `${type}.${key}`;\n    let res = await browser.storage.local.get(k);\n    return res[k];\n}\nfunction remove ( type, key){\n    browser.storage.local.remove(`${type}.${key}`);\n}\nfunction setup(){\n    browser.storage.local.clear();//returns promise\n}\nasync function contains(type, key){\n    let res = await browser.storage.local.get(`${type}.${key}`);\n    return !( Object.keys(res).length === 0 && res.constructor === Object);\n}\nasync function findAll(type){\n    let allStoredObjects = await browser.storage.local.get();\n    let resultArray = [];\n    for ( let key in allStoredObjects ){\n\tif ( allStoredObjects.hasOwnProperty(key)){\n\t    if ( key.startsWith(type)){\n\t\tlet obj = {};\n\t\tobj.id = key;\n\t\tobj.val = allStoredObjects[key];\n\t\tresultArray.push( obj );\n\t    }\n\t}\n    }\n    return resultArray;\n}\n\n\n//# sourceURL=webpack:///./src/storageDao.js?");

/***/ }),

/***/ "./src/stringUtils.js":
/*!****************************!*\
  !*** ./src/stringUtils.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fast_levenshtein__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-levenshtein */ \"./node_modules/fast-levenshtein/levenshtein.js\");\n/* harmony import */ var fast_levenshtein__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_levenshtein__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var double_metaphone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-metaphone */ \"./node_modules/double-metaphone/index.js\");\n/* harmony import */ var double_metaphone__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(double_metaphone__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  String manipulation stuff\n*/\n\n\n\n// radix tree min str length\nvar rTreeMinLength = 2;\nvar kwMinLength = 3;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    toLowerCase : lowerCase,\n    tokenize : tokenizer,\n    filterEmptyString : isNotEmpty,\n    rTree : radixTree,\n    levenshtein: gld,\n    // tokenize, metaphone, remove dupes\n    toSearchable : function ( query ){\n\tlet tokenized = lcTokenizeFilter(query);\n\tlet metaphoned = [];\n\ttokenized.forEach(function (token){\n\t    metaphoned = metaphoned.concat(double_metaphone__WEBPACK_IMPORTED_MODULE_1___default()(token));\n\t});\n\tlet result = Array.from(new Set(metaphoned));\n\treturn result;\n    },\n    toComparable : function (text){\n\tlet tokenized = lcTokenizeFilter(text);\n\tlet result = Array.from(new Set(tokenized));\n\treturn result;\n    },\n    toIndexable : function (str){\n\tlet tokenArray = lcTokenizeFilter(str);\n\tlet metaphoned = [];\n\ttokenArray.forEach(function(token){\n\t    metaphoned = metaphoned.concat(double_metaphone__WEBPACK_IMPORTED_MODULE_1___default()(token));\n\t});\n\tmetaphoned = Array.from(new Set(metaphoned));\n\tlet prefixedIndexes = [];\n\tmetaphoned.forEach(function(mtp){\n\t    prefixedIndexes = prefixedIndexes.concat(radixTree(mtp));\n\t});\n\tprefixedIndexes = Array.from(new Set(prefixedIndexes));\n\treturn prefixedIndexes;\n    },\n    urlToIndexable : urlToIndexableTokens,\n    urlToTokens: urlTokenizer\n});\n\n\nfunction radixTree ( str ) {\n    if ( str.length <= rTreeMinLength ){\n        return [str];\n    }\n    else{\n        let result = [];\n        for ( let i = rTreeMinLength ; i <= str.length ; i++ ){\n\t    result.push(str.substr(0, i));\n        }\n\treturn result;\n    }\n}\nfunction lowerCase( str ){\n    return str.toLowerCase();\n}\nfunction tokenizer( str ){\n    return str.split(/[\\W_]/);\n}\nfunction isNotEmpty( str ) {\n    return str !== \"\";\n}\nfunction tokenIsBigEnough(str){\n    return str.length >= kwMinLength;\n}\n/*\n  Generalized levenshtein dist \n  Returns double in [0,1]\n*/\nfunction gld (stra, strb){\n    let ld = fast_levenshtein__WEBPACK_IMPORTED_MODULE_0___default.a.get ( stra, strb );\n    let result = 1 - ((2 * ld) / (stra.length + strb.length + ld ));\n    return result;\n}\n//convenience function\nfunction lcTokenizeFilter(str){\n    return tokenizer(lowerCase(str)).filter(isNotEmpty);\n}\n\nfunction urlTokenizer(urlStr){\n    let url = new URL(lowerCase(urlStr));\n    let domain = url.hostname;\n    let path = url.pathname;\n    let tokens = tokenizer ( domain );\n    tokens =tokens.concat( tokenizer (path ));\n    tokens = tokens.filter(tokenIsBigEnough);\n    tokens = Array.from(new Set(tokens));\n    return tokens;\n}\n\n\nfunction urlToIndexableTokens ( urlStr ) {\n    let tokens = urlTokenizer(urlStr);\n    \n    let metaphoned = [];\n    tokens.forEach(function(token){\n\tmetaphoned = metaphoned.concat(double_metaphone__WEBPACK_IMPORTED_MODULE_1___default()(token));\n    });\n    metaphoned = Array.from(new Set(metaphoned));\n    \n    let prefixedIndexes = [];\n    metaphoned.forEach(function(mtp){\n\tprefixedIndexes = prefixedIndexes.concat(radixTree(mtp));\n    });\n    prefixedIndexes = Array.from(new Set(prefixedIndexes));\n    \n    return prefixedIndexes;\n}\n\n\n//# sourceURL=webpack:///./src/stringUtils.js?");

/***/ }),

/***/ "./src/tabs.js":
/*!*********************!*\
  !*** ./src/tabs.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.js */ \"./src/settings.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/*\n  Handles opened tabs\n*/\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    getAll: loadTabs,\n    init: function(){\n\t//setup event listeners\n\tbrowser.tabs.onCreated.addListener(handleTabCreated);\n\tbrowser.tabs.onUpdated.addListener(handleTabUpdated);\n\tbrowser.tabs.onRemoved.addListener(handleTabCreated);\n    }\n});\n\n\nfunction handleTabCreated( tab ){\n    let toIndex = new Map();\n    _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get().then(function(settings){\n\tif ( settings.indexTabs === false ){\n\t    return;\n\t}\n\tlet parsedTab = parseTab(tab);\n\tif (! filterTabs (parsedTab)){\n\t    return;\n\t}\n\ttoIndex.set(\"tab_\"+parsedTab.id, parsedTab);\n\tconsole.log(\"index tab\");\n\tconsole.log(toIndex);\n\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(toIndex);\n    });\n}\n\nfunction handleTabUpdated(tabId, updatedInfo, tab){\n    let toIndex = new Map();\n    _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get().then(function(settings){\n\tif ( settings.indexTabs === false ){\n\t    return;\n\t}\n\tlet parsedTab = parseTab(tab);\n\tif (! filterTabs (parsedTab)){\n\t    return;\n\t}\n\ttoIndex.set(\"tab_\"+parsedTab.id, parsedTab);\n\tconsole.log(\"update tab\");\n\tconsole.log(toIndex);\n\t_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(toIndex);\n    });\n}\n\nfunction handleTabRemoved( tabId, removeInfo ){\n    console.log(\"remove tab \"+tabId);\n    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].disindex( \"tab_\"+tabId );\n}\n\nasync function loadTabs(){\n    // look at settings\n    let toIndex = new Map();\n    let settings = await _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get();\n    if ( settings.indexTabs === false ){\n\treturn toIndex;\n    }\n    //get all tabs\n    let tabArray = await browser.tabs.query({});\n    //perse relevant stuff, remove unusable tabs\n    tabArray = tabArray.map( parseTab ).filter(filterTabs);\n    console.log(\"tabs !\");\n    console.log(tabArray);\n    \n    for (let tab of tabArray ){\n\ttoIndex.set(\"tab_\"+tab.id, tab);\n    }\n    return toIndex;\n}\n\n\n/*\n  Returns true if tab has valid title, url and id\n*/\nfunction filterTabs(tabObject){\n    return (tabObject.title !== undefined && tabObject.title !== \"\" &&\n\t    tabObject.url !== undefined && tabObject.url !== \"\" && tabObject.url.startsWith(\"http\") &&\n\t   tabObject.id !== undefined && tabObject.id !== \"\");\n}\n\nfunction parseTab( rawTab ){\n    return{\n\t\"title\": rawTab.title,\n\t\"url\": rawTab.url,\n\t\"id\": rawTab.id,\n\t\"type\": \"tab\",\n\t\"date\": rawTab.lastAccessed\n    };\n}\n\n\n//# sourceURL=webpack:///./src/tabs.js?");

/***/ })

/******/ });