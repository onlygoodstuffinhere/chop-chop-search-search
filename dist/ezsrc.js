/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/double-metaphone/index.js":
/*!************************************************!*\
  !*** ./node_modules/double-metaphone/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* Expose. */\nmodule.exports = doubleMetaphone;\n\n/* Match vowels (including `Y`). */\nvar VOWELS = /[AEIOUY]/;\n\n/* Match few Slavo-Germanic values. */\nvar SLAVO_GERMANIC = /W|K|CZ|WITZ/;\n\n/* Match few Germanic values. */\nvar GERMANIC = /^(VAN |VON |SCH)/;\n\n/* Match initial values of which the first character\n * should be skipped. */\nvar INITIAL_EXCEPTIONS = /^(GN|KN|PN|WR|PS)/;\n\n/* Match initial Greek-like values of which the `CH`\n * sounds like `K`. */\nvar GREEK_INITIAL_CH = /^CH(IA|EM|OR([^E])|YM|ARAC|ARIS)/;\n\n/* Match Greek-like values of which the `CH` sounds\n * like `K`. */\nvar GREEK_CH = /ORCHES|ARCHIT|ORCHID/;\n\n/* Match values which when following `CH`, transform `CH`\n * to sound like `K`. */\nvar CH_FOR_KH = /[ BFHLMNRVW]/;\n\n/* Match values which when preceding a vowel and `UGH`,\n * sound like `F`. */\nvar G_FOR_F = /[CGLRT]/;\n\n/* Match initial values which sound like either `K` or `J`. */\nvar INITIAL_G_FOR_KJ = /Y[\\s\\S]|E[BILPRSY]|I[BELN]/;\n\n/* Match initial values which sound like either `K` or `J`. */\nvar INITIAL_ANGER_EXCEPTION = /^[DMR]ANGER/;\n\n/* Match values which when following `GY`, do not sound\n * like `K` or `J`. */\nvar G_FOR_KJ = /[EGIR]/;\n\n/* Match values which when following `J`, do not sound `J`. */\nvar J_FOR_J_EXCEPTION = /[LTKSNMBZ]/;\n\n/* Match values which might sound like `L`. */\nvar ALLE = /AS|OS/;\n\n/* Match Germanic values preceding `SH` which sound\n * like `S`. */\nvar H_FOR_S = /EIM|OEK|OLM|OLZ/;\n\n/* Match Dutch values following `SCH` which sound like\n * either `X` and `SK`, or `SK`. */\nvar DUTCH_SCH = /E[DMNR]|UY|OO/;\n\n/**\n * Get the phonetics according to the Double Metaphone\n * algorithm from a value.\n *\n * @param {string} value - value to detect phonetics for.\n * @return {Array.<string>} - Two phonetics.\n */\nfunction doubleMetaphone(value) {\n  var primary = '';\n  var secondary = '';\n  var index = 0;\n  var length = value.length;\n  var last = length - 1;\n  var isSlavoGermanic;\n  var isGermanic;\n  var subvalue;\n  var next;\n  var prev;\n  var nextnext;\n  var characters;\n\n  value = String(value).toUpperCase() + '     ';\n  isSlavoGermanic = SLAVO_GERMANIC.test(value);\n  isGermanic = GERMANIC.test(value);\n  characters = value.split('');\n\n  /* Skip this at beginning of word. */\n  if (INITIAL_EXCEPTIONS.test(value)) {\n    index++;\n  }\n\n  /* Initial X is pronounced Z, which maps to S. Such as `Xavier` */\n  if (characters[0] === 'X') {\n    primary += 'S';\n    secondary += 'S';\n    index++;\n  }\n\n  while (index < length) {\n    prev = characters[index - 1];\n    next = characters[index + 1];\n    nextnext = characters[index + 2];\n\n    switch (characters[index]) {\n      case 'A':\n      case 'E':\n      case 'I':\n      case 'O':\n      case 'U':\n      case 'Y':\n      case 'À':\n      case 'Ê':\n      case 'É':\n        if (index === 0) {\n          /* All initial vowels now map to `A`. */\n          primary += 'A';\n          secondary += 'A';\n        }\n\n        index++;\n\n        break;\n      case 'B':\n        primary += 'P';\n        secondary += 'P';\n\n        if (next === 'B') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'Ç':\n        primary += 'S';\n        secondary += 'S';\n        index++;\n\n        break;\n      case 'C':\n        /* Various Germanic: */\n        if (\n          prev === 'A' &&\n          next === 'H' &&\n          nextnext !== 'I' &&\n          !VOWELS.test(characters[index - 2]) &&\n          (\n            nextnext !== 'E' ||\n            (\n              subvalue = value.slice(index - 2, index + 4) &&\n              (subvalue === 'BACHER' || subvalue === 'MACHER')\n            )\n          )\n        ) {\n          primary += 'K';\n          secondary += 'K';\n          index += 2;\n\n          break;\n        }\n\n        /* Special case for `Caesar`. */\n        if (index === 0 && value.slice(index + 1, index + 6) === 'AESAR') {\n          primary += 'S';\n          secondary += 'S';\n          index += 2;\n\n          break;\n        }\n\n        /* Italian `Chianti`. */\n        if (value.slice(index + 1, index + 4) === 'HIA') {\n          primary += 'K';\n          secondary += 'K';\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'H') {\n          /* Find `Michael`. */\n          if (\n            index > 0 &&\n            nextnext === 'A' &&\n            characters[index + 3] === 'E'\n          ) {\n            primary += 'K';\n            secondary += 'X';\n            index += 2;\n\n            break;\n          }\n\n          /* Greek roots such as `chemistry`, `chorus`. */\n          if (index === 0 && GREEK_INITIAL_CH.test(value)) {\n            primary += 'K';\n            secondary += 'K';\n            index += 2;\n\n            break;\n          }\n\n          /* Germanic, Greek, or otherwise `CH` for `KH` sound. */\n          if (\n            isGermanic ||\n            /* Such as 'architect' but not 'arch', orchestra',\n             * 'orchid'. */\n            GREEK_CH.test(value.slice(index - 2, index + 4)) ||\n            (nextnext === 'T' || nextnext === 'S') ||\n            (\n                (\n                    index === 0 ||\n                    prev === 'A' ||\n                    prev === 'E' ||\n                    prev === 'O' ||\n                    prev === 'U'\n                ) &&\n                /* Such as `wachtler`, `weschsler`, but not\n                 * `tichner`. */\n                CH_FOR_KH.test(nextnext)\n            )\n          ) {\n            primary += 'K';\n            secondary += 'K';\n          } else if (index === 0) {\n            primary += 'X';\n            secondary += 'X';\n          /* Such as 'McHugh'. */\n          } else if (value.slice(0, 2) === 'MC') {\n            /* Bug? Why matching absolute? what about McHiccup? */\n            primary += 'K';\n            secondary += 'K';\n          } else {\n            primary += 'X';\n            secondary += 'K';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        /* Such as `Czerny`. */\n        if (\n          next === 'Z' &&\n          value.slice(index - 2, index) !== 'WI'\n        ) {\n          primary += 'S';\n          secondary += 'X';\n          index += 2;\n\n          break;\n        }\n\n        /* Such as `Focaccia`. */\n        if (value.slice(index + 1, index + 4) === 'CIA') {\n          primary += 'X';\n          secondary += 'X';\n          index += 3;\n\n          break;\n        }\n\n        /* Double `C`, but not `McClellan`. */\n        if (\n          next === 'C' &&\n          !(index === 1 && characters[0] === 'M')\n        ) {\n          /* Such as `Bellocchio`, but not `Bacchus`. */\n          if (\n            (\n              nextnext === 'I' ||\n              nextnext === 'E' ||\n              nextnext === 'H'\n            ) &&\n            value.slice(index + 2, index + 4) !== 'HU'\n          ) {\n            subvalue = value.slice(index - 1, index + 4);\n\n            /* Such as `Accident`, `Accede`, `Succeed`. */\n            if (\n              (index === 1 && prev === 'A') ||\n              subvalue === 'UCCEE' ||\n              subvalue === 'UCCES'\n            ) {\n              primary += 'KS';\n              secondary += 'KS';\n            /* Such as `Bacci`, `Bertucci`, other Italian. */\n            } else {\n              primary += 'X';\n              secondary += 'X';\n            }\n\n            index += 3;\n\n            break;\n          } else {\n            /* Pierce's rule. */\n            primary += 'K';\n            secondary += 'K';\n            index += 2;\n\n            break;\n          }\n        }\n\n        if (next === 'G' || next === 'K' || next === 'Q') {\n          primary += 'K';\n          secondary += 'K';\n          index += 2;\n\n          break;\n        }\n\n        /* Italian. */\n        if (\n          next === 'I' &&\n          /* Bug: The original algorithm also calls for A (as\n           * in CIA), which is already taken care of above. */\n          (nextnext === 'E' || nextnext === 'O')\n        ) {\n          primary += 'S';\n          secondary += 'X';\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'I' || next === 'E' || next === 'Y') {\n          primary += 'S';\n          secondary += 'S';\n          index += 2;\n\n          break;\n        }\n\n        primary += 'K';\n        secondary += 'K';\n\n        /* Skip two extra characters ahead in `Mac Caffrey`,\n         * `Mac Gregor`. */\n        if (\n          next === ' ' &&\n          (nextnext === 'C' || nextnext === 'G' || nextnext === 'Q')\n        ) {\n          index += 3;\n          break;\n        }\n\n        /* Bug: Already covered above.\n         *\n         * if (\n         *   next === 'K' ||\n         *   next === 'Q' ||\n         *   (next === 'C' && nextnext !== 'E' && nextnext !== 'I')\n         * ) {\n         *   index++;\n         * }\n         */\n        index++;\n\n        break;\n      case 'D':\n        if (next === 'G') {\n          /* Such as `edge`. */\n          if (nextnext === 'E' || nextnext === 'I' || nextnext === 'Y') {\n            primary += 'J';\n            secondary += 'J';\n            index += 3;\n          /* Such as `Edgar`. */\n          } else {\n            primary += 'TK';\n            secondary += 'TK';\n            index += 2;\n          }\n\n          break;\n        }\n\n        if (next === 'T' || next === 'D') {\n          primary += 'T';\n          secondary += 'T';\n          index += 2;\n\n          break;\n        }\n\n        primary += 'T';\n        secondary += 'T';\n        index++;\n\n        break;\n      case 'F':\n        if (next === 'F') {\n          index++;\n        }\n\n        index++;\n        primary += 'F';\n        secondary += 'F';\n\n        break;\n      case 'G':\n        if (next === 'H') {\n          if (index > 0 && !VOWELS.test(prev)) {\n            primary += 'K';\n            secondary += 'K';\n            index += 2;\n\n            break;\n          }\n\n          /* Such as `Ghislane`, `Ghiradelli`. */\n          if (index === 0) {\n            if (nextnext === 'I') {\n              primary += 'J';\n              secondary += 'J';\n            } else {\n              primary += 'K';\n              secondary += 'K';\n            }\n\n            index += 2;\n\n            break;\n          }\n\n          /* Parker's rule (with some further refinements). */\n          if (\n            (\n              /* Such as `Hugh`.  The comma is not a bug. */\n              subvalue = characters[index - 2],\n              subvalue === 'B' ||\n              subvalue === 'H' ||\n              subvalue === 'D'\n            ) ||\n            (\n              /* Such as `bough`.  The comma is not a bug. */\n              subvalue = characters[index - 3],\n              subvalue === 'B' ||\n              subvalue === 'H' ||\n              subvalue === 'D'\n            ) ||\n            (\n              /* Such as `Broughton`.  The comma is not a bug. */\n              subvalue = characters[index - 4],\n              subvalue === 'B' ||\n              subvalue === 'H'\n            )\n          ) {\n            index += 2;\n\n            break;\n          }\n\n          /* Such as `laugh`, `McLaughlin`, `cough`, `gough`,\n           * `rough`, `tough`. */\n          if (\n            index > 2 &&\n            prev === 'U' &&\n            G_FOR_F.test(characters[index - 3])\n          ) {\n            primary += 'F';\n            secondary += 'F';\n          } else if (index > 0 && prev !== 'I') {\n            primary += 'K';\n            secondary += 'K';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'N') {\n          if (\n            index === 1 &&\n            VOWELS.test(characters[0]) &&\n            !isSlavoGermanic\n          ) {\n            primary += 'KN';\n            secondary += 'N';\n          /* Not like `Cagney`. */\n          } else if (\n            value.slice(index + 2, index + 4) !== 'EY' &&\n            value.slice(index + 1) !== 'Y' &&\n            !isSlavoGermanic\n          ) {\n            primary += 'N';\n            secondary += 'KN';\n          } else {\n            primary += 'KN';\n            secondary += 'KN';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        /* Such as `Tagliaro`. */\n        if (\n          value.slice(index + 1, index + 3) === 'LI' &&\n          !isSlavoGermanic\n        ) {\n          primary += 'KL';\n          secondary += 'L';\n          index += 2;\n\n          break;\n        }\n\n        /* -ges-, -gep-, -gel- at beginning. */\n        if (\n          index === 0 &&\n          INITIAL_G_FOR_KJ.test(value.slice(1, 3))\n        ) {\n          primary += 'K';\n          secondary += 'J';\n          index += 2;\n\n          break;\n        }\n\n        /* -ger-, -gy-. */\n        if (\n          (\n            value.slice(index + 1, index + 3) === 'ER' &&\n            prev !== 'I' && prev !== 'E' &&\n            !INITIAL_ANGER_EXCEPTION.test(value.slice(0, 6))\n          ) ||\n          (next === 'Y' && !G_FOR_KJ.test(prev))\n        ) {\n          primary += 'K';\n          secondary += 'J';\n          index += 2;\n\n          break;\n        }\n\n        /* Italian such as `biaggi`. */\n        if (\n          next === 'E' ||\n          next === 'I' ||\n          next === 'Y' ||\n          (\n              (prev === 'A' || prev === 'O') &&\n              next === 'G' &&\n              nextnext === 'I'\n          )\n        ) {\n          /* Obvious Germanic. */\n          if (\n            value.slice(index + 1, index + 3) === 'ET' ||\n            isGermanic\n          ) {\n            primary += 'K';\n            secondary += 'K';\n          } else {\n            primary += 'J';\n\n            /* Always soft if French ending. */\n            if (value.slice(index + 1, index + 5) === 'IER ') {\n              secondary += 'J';\n            } else {\n              secondary += 'K';\n            }\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'G') {\n          index++;\n        }\n\n        index++;\n\n        primary += 'K';\n        secondary += 'K';\n\n        break;\n      case 'H':\n        /* Only keep if first & before vowel or btw. 2 vowels. */\n        if (VOWELS.test(next) && (index === 0 || VOWELS.test(prev))) {\n          primary += 'H';\n          secondary += 'H';\n\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'J':\n        /* Obvious Spanish, `jose`, `San Jacinto`. */\n        if (\n          value.slice(index, index + 4) === 'JOSE' ||\n          value.slice(0, 4) === 'SAN '\n        ) {\n          if (\n            value.slice(0, 4) === 'SAN ' ||\n            (\n              index === 0 &&\n              characters[index + 4] === ' '\n            )\n          ) {\n            primary += 'H';\n            secondary += 'H';\n          } else {\n            primary += 'J';\n            secondary += 'H';\n          }\n\n          index++;\n\n          break;\n        }\n\n        if (\n          index === 0\n          /* Bug: unreachable (see previous statement).\n           * && value.slice(index, index + 4) !== 'JOSE'. */\n        ) {\n          primary += 'J';\n\n          /* Such as `Yankelovich` or `Jankelowicz`. */\n          secondary += 'A';\n        /* Spanish pron. of such as `bajador`. */\n        } else if (\n          !isSlavoGermanic &&\n          (next === 'A' || next === 'O') &&\n          VOWELS.test(prev)\n        ) {\n          primary += 'J';\n          secondary += 'H';\n        } else if (index === last) {\n          primary += 'J';\n        } else if (\n          prev !== 'S' && prev !== 'K' && prev !== 'L' &&\n          !J_FOR_J_EXCEPTION.test(next)\n        ) {\n          primary += 'J';\n          secondary += 'J';\n        /* It could happen. */\n        } else if (next === 'J') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'K':\n        if (next === 'K') {\n          index++;\n        }\n\n        primary += 'K';\n        secondary += 'K';\n        index++;\n\n        break;\n      case 'L':\n        if (next === 'L') {\n          /* Spanish such as `cabrillo`, `gallegos`. */\n          if (\n            (\n              index === length - 3 &&\n              (\n                (prev === 'A' && nextnext === 'E') ||\n                (prev === 'I' && (nextnext === 'O' || nextnext === 'A'))\n              )\n            ) ||\n            (\n              prev === 'A' &&\n              nextnext === 'E' &&\n              (\n                (characters[last] === 'A' || characters[last] === 'O') ||\n                ALLE.test(value.slice(last - 1, length))\n              )\n            )\n          ) {\n            primary += 'L';\n            index += 2;\n\n            break;\n          }\n\n          index++;\n        }\n\n        primary += 'L';\n        secondary += 'L';\n        index++;\n\n        break;\n      case 'M':\n        if (\n          next === 'M' ||\n          /* Such as `dumb`, `thumb`. */\n          (\n            prev === 'U' &&\n            next === 'B' &&\n            (index + 1 === last || value.slice(index + 2, index + 4) === 'ER')\n          )\n        ) {\n          index++;\n        }\n\n        index++;\n        primary += 'M';\n        secondary += 'M';\n\n        break;\n      case 'N':\n        if (next === 'N') {\n          index++;\n        }\n\n        index++;\n        primary += 'N';\n        secondary += 'N';\n\n        break;\n      case 'Ñ':\n        index++;\n        primary += 'N';\n        secondary += 'N';\n\n        break;\n      case 'P':\n        if (next === 'H') {\n          primary += 'F';\n          secondary += 'F';\n          index += 2;\n\n          break;\n        }\n\n        /* Also account for `campbell` and `raspberry`. */\n        subvalue = next;\n\n        if (subvalue === 'P' || subvalue === 'B') {\n          index++;\n        }\n\n        index++;\n\n        primary += 'P';\n        secondary += 'P';\n\n        break;\n      case 'Q':\n        if (next === 'Q') {\n          index++;\n        }\n\n        index++;\n        primary += 'K';\n        secondary += 'K';\n\n        break;\n      case 'R':\n        /* French such as `Rogier`, but exclude `Hochmeier`. */\n        if (\n          index === last &&\n          !isSlavoGermanic &&\n          prev === 'E' &&\n          characters[index - 2] === 'I' &&\n          characters[index - 4] !== 'M' &&\n          (\n            characters[index - 3] !== 'E' &&\n            characters[index - 3] !== 'A'\n          )\n        ) {\n          secondary += 'R';\n        } else {\n          primary += 'R';\n          secondary += 'R';\n        }\n\n        if (next === 'R') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'S':\n        /* Special cases `island`, `isle`, `carlisle`, `carlysle`. */\n        if (next === 'L' && (prev === 'I' || prev === 'Y')) {\n          index++;\n\n          break;\n        }\n\n        /* Special case `sugar-`. */\n        if (index === 0 && value.slice(1, 5) === 'UGAR') {\n          primary += 'X';\n          secondary += 'S';\n          index++;\n\n          break;\n        }\n\n        if (next === 'H') {\n          /* Germanic. */\n          if (H_FOR_S.test(value.slice(index + 1, index + 5))) {\n            primary += 'S';\n            secondary += 'S';\n          } else {\n            primary += 'X';\n            secondary += 'X';\n          }\n\n          index += 2;\n          break;\n        }\n\n        if (\n          next === 'I' &&\n          (nextnext === 'O' || nextnext === 'A')\n          /* Bug: Already covered by previous branch\n           * || value.slice(index, index + 4) === 'SIAN' */\n        ) {\n          if (isSlavoGermanic) {\n            primary += 'S';\n            secondary += 'S';\n          } else {\n            primary += 'S';\n            secondary += 'X';\n          }\n\n          index += 3;\n\n          break;\n        }\n\n        /* German & Anglicization's, such as `Smith` match `Schmidt`,\n         * `snider` match `Schneider`. Also, -sz- in slavic language\n         * although in hungarian it is pronounced `s`. */\n        if (\n          next === 'Z' ||\n          (\n            index === 0 &&\n            (next === 'L' || next === 'M' || next === 'N' || next === 'W')\n          )\n        ) {\n          primary += 'S';\n          secondary += 'X';\n\n          if (next === 'Z') {\n            index++;\n          }\n\n          index++;\n\n          break;\n        }\n\n        if (next === 'C') {\n          /* Schlesinger's rule. */\n          if (nextnext === 'H') {\n            subvalue = value.slice(index + 3, index + 5);\n\n            /* Dutch origin, such as `school`, `schooner`. */\n            if (DUTCH_SCH.test(subvalue)) {\n              /* Such as `schermerhorn`, `schenker`. */\n              if (subvalue === 'ER' || subvalue === 'EN') {\n                primary += 'X';\n                secondary += 'SK';\n              } else {\n                primary += 'SK';\n                secondary += 'SK';\n              }\n\n              index += 3;\n\n              break;\n            }\n\n            if (\n              index === 0 &&\n              !VOWELS.test(characters[3]) &&\n              characters[3] !== 'W'\n            ) {\n              primary += 'X';\n              secondary += 'S';\n            } else {\n              primary += 'X';\n              secondary += 'X';\n            }\n\n            index += 3;\n\n            break;\n          }\n\n          if (\n            nextnext === 'I' ||\n            nextnext === 'E' ||\n            nextnext === 'Y'\n          ) {\n            primary += 'S';\n            secondary += 'S';\n            index += 3;\n            break;\n          }\n\n          primary += 'SK';\n          secondary += 'SK';\n          index += 3;\n\n          break;\n        }\n\n        subvalue = value.slice(index - 2, index);\n\n        /* French such as `resnais`, `artois`. */\n        if (\n          index === last &&\n          (subvalue === 'AI' || subvalue === 'OI')\n        ) {\n          secondary += 'S';\n        } else {\n          primary += 'S';\n          secondary += 'S';\n        }\n\n        if (\n          next === 'S'\n          /* Bug: already taken care of by `German &\n           * Anglicization's` above:\n           * || next === 'Z' */\n        ) {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'T':\n        if (\n          next === 'I' &&\n          nextnext === 'O' &&\n          characters[index + 3] === 'N'\n        ) {\n          primary += 'X';\n          secondary += 'X';\n          index += 3;\n\n          break;\n        }\n\n        subvalue = value.slice(index + 1, index + 3);\n\n        if (\n          (next === 'I' && nextnext === 'A') ||\n          (next === 'C' && nextnext === 'H')\n        ) {\n          primary += 'X';\n          secondary += 'X';\n          index += 3;\n\n          break;\n        }\n\n        if (next === 'H' || (next === 'T' && nextnext === 'H')) {\n          /* Special case `Thomas`, `Thames` or Germanic. */\n          if (\n            isGermanic ||\n            (\n              (nextnext === 'O' || nextnext === 'A') &&\n              characters[index + 3] === 'M'\n            )\n          ) {\n            primary += 'T';\n            secondary += 'T';\n          } else {\n            primary += '0';\n            secondary += 'T';\n          }\n\n          index += 2;\n\n          break;\n        }\n\n        if (next === 'T' || next === 'D') {\n          index++;\n        }\n\n        index++;\n        primary += 'T';\n        secondary += 'T';\n\n        break;\n      case 'V':\n        if (next === 'V') {\n          index++;\n        }\n\n        primary += 'F';\n        secondary += 'F';\n        index++;\n\n        break;\n      case 'W':\n        /* Can also be in middle of word (as already taken care of\n         * for initial). */\n        if (next === 'R') {\n          primary += 'R';\n          secondary += 'R';\n          index += 2;\n\n          break;\n        }\n\n        if (index === 0) {\n          /* `Wasserman` should match `Vasserman`. */\n          if (VOWELS.test(next)) {\n            primary += 'A';\n            secondary += 'F';\n          } else if (next === 'H') {\n            /* Need `Uomo` to match `Womo`. */\n            primary += 'A';\n            secondary += 'A';\n          }\n        }\n\n        /* `Arnow` should match `Arnoff`. */\n        if (\n          (\n            (prev === 'E' || prev === 'O') &&\n            next === 'S' &&\n            nextnext === 'K' &&\n            (\n              characters[index + 3] === 'I' ||\n              characters[index + 3] === 'Y'\n            )\n          ) ||\n          /* Maybe a bug? Shouldn't this be general Germanic? */\n          value.slice(0, 3) === 'SCH' ||\n          (index === last && VOWELS.test(prev))\n        ) {\n          secondary += 'F';\n          index++;\n\n          break;\n        }\n\n        /* Polish such as `Filipowicz`. */\n        if (\n          next === 'I' &&\n          (nextnext === 'C' || nextnext === 'T') &&\n          characters[index + 3] === 'Z'\n        ) {\n          primary += 'TS';\n          secondary += 'FX';\n          index += 4;\n\n          break;\n        }\n\n        index++;\n\n        break;\n      case 'X':\n        /* French such as `breaux`. */\n        if (\n          !(\n            index === last &&\n            (\n              /* Bug: IAU and EAU also match by AU\n               * (/IAU|EAU/.test(value.slice(index - 3, index))) || */\n              (\n                prev === 'U' &&\n                (characters[index - 2] === 'A' || characters[index - 2] === 'O')\n              )\n            )\n          )\n        ) {\n          primary += 'KS';\n          secondary += 'KS';\n        }\n\n        if (next === 'C' || next === 'X') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      case 'Z':\n        /* Chinese pinyin such as `Zhao`. */\n        if (next === 'H') {\n          primary += 'J';\n          secondary += 'J';\n          index += 2;\n\n          break;\n        } else if (\n          (\n            next === 'Z' &&\n            (nextnext === 'A' || nextnext === 'I' || nextnext === 'O')\n          ) ||\n          (isSlavoGermanic && index > 0 && prev !== 'T')\n        ) {\n          primary += 'S';\n          secondary += 'TS';\n        } else {\n          primary += 'S';\n          secondary += 'S';\n        }\n\n        if (next === 'Z') {\n          index++;\n        }\n\n        index++;\n\n        break;\n      default:\n        index++;\n    }\n  }\n\n  return [primary, secondary];\n}\n\n\n//# sourceURL=webpack:///./node_modules/double-metaphone/index.js?");

/***/ }),

/***/ "./node_modules/fast-levenshtein/levenshtein.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-levenshtein/levenshtein.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n  'use strict';\n  \n  var collator;\n  try {\n    collator = (typeof Intl !== \"undefined\" && typeof Intl.Collator !== \"undefined\") ? Intl.Collator(\"generic\", { sensitivity: \"base\" }) : null;\n  } catch (err){\n    console.log(\"Collator could not be initialized and wouldn't be used\");\n  }\n  // arrays to re-use\n  var prevRow = [],\n    str2Char = [];\n  \n  /**\n   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\n   */\n  var Levenshtein = {\n    /**\n     * Calculate levenshtein distance of the two strings.\n     *\n     * @param str1 String the first string.\n     * @param str2 String the second string.\n     * @param [options] Additional options.\n     * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.\n     * @return Integer the levenshtein distance (0 and above).\n     */\n    get: function(str1, str2, options) {\n      var useCollator = (options && collator && options.useCollator);\n      \n      var str1Len = str1.length,\n        str2Len = str2.length;\n      \n      // base cases\n      if (str1Len === 0) return str2Len;\n      if (str2Len === 0) return str1Len;\n\n      // two rows\n      var curCol, nextCol, i, j, tmp;\n\n      // initialise previous row\n      for (i=0; i<str2Len; ++i) {\n        prevRow[i] = i;\n        str2Char[i] = str2.charCodeAt(i);\n      }\n      prevRow[str2Len] = str2Len;\n\n      var strCmp;\n      if (useCollator) {\n        // calculate current row distance from previous row using collator\n        for (i = 0; i < str1Len; ++i) {\n          nextCol = i + 1;\n\n          for (j = 0; j < str2Len; ++j) {\n            curCol = nextCol;\n\n            // substution\n            strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));\n\n            nextCol = prevRow[j] + (strCmp ? 0 : 1);\n\n            // insertion\n            tmp = curCol + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n            // deletion\n            tmp = prevRow[j + 1] + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n\n            // copy current col value into previous (in preparation for next iteration)\n            prevRow[j] = curCol;\n          }\n\n          // copy last col value into previous (in preparation for next iteration)\n          prevRow[j] = nextCol;\n        }\n      }\n      else {\n        // calculate current row distance from previous row without collator\n        for (i = 0; i < str1Len; ++i) {\n          nextCol = i + 1;\n\n          for (j = 0; j < str2Len; ++j) {\n            curCol = nextCol;\n\n            // substution\n            strCmp = str1.charCodeAt(i) === str2Char[j];\n\n            nextCol = prevRow[j] + (strCmp ? 0 : 1);\n\n            // insertion\n            tmp = curCol + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n            // deletion\n            tmp = prevRow[j + 1] + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n\n            // copy current col value into previous (in preparation for next iteration)\n            prevRow[j] = curCol;\n          }\n\n          // copy last col value into previous (in preparation for next iteration)\n          prevRow[j] = nextCol;\n        }\n      }\n      return nextCol;\n    }\n\n  };\n\n  // amd\n  if (\"function\" !== \"undefined\" && __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") !== null && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Levenshtein;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // commonjs\n  else if (typeof module !== \"undefined\" && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\n    module.exports = Levenshtein;\n  }\n  // web worker\n  else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\n    self.Levenshtein = Levenshtein;\n  }\n  // browser main thread\n  else if (typeof window !== \"undefined\" && window !== null) {\n    window.Levenshtein = Levenshtein;\n  }\n}());\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/fast-levenshtein/levenshtein.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/bookmarks.js":
/*!**************************!*\
  !*** ./src/bookmarks.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/* ---------------------------------------------------------------------\n  Fetch bookmarks on install, get new bookmarks, get deleted bookmarks\n-----------------------------------------------------------------------*/\n//import md5 from 'blueimp-md5';\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    getAll : async function getAll(){\n\ttry{\n\t    const bmRootArray = await browser.bookmarks.getTree();\n\t    let bmRoot = bmRootArray[0];\n\t    let result = walkBmTree(bmRoot);\n\t    return result;\n\t}\n\tcatch(err){\n\t    console.log(`fugg ${err}`);\n\t}\n    },\n    init : function(){\n\tbrowser.bookmarks.onCreated.addListener(indexBm);\n\tbrowser.bookmarks.onRemoved.addListener(disindexBm);\n\t//browser.bookmarks.onChanged.addListener(); //TODO \n    }\n\n});\n\n\nfunction walkBmTree ( bmNode ) {\n    let bmMap = new Map();\n    if ( bmNode.type === \"folder\" ) {\n\tfor( let bmChild of bmNode.children ){\n            //bmList = bmList.concat(walkBmTree(bmChild));\n\t    for ( var [k,v] of walkBmTree(bmChild)){\n\t\tbmMap.set(k,v);\n\t    }\n\t}\n    }\n    else if ( bmNode.type === \"bookmark\" && bmNode.url.startsWith(\"http\")){\n\tlet bm = bmNodeToBm(bmNode);\n\tbmMap.set(bm.id,bm);\n    }\n    return bmMap;\n}\n\n/*function getBmId ( url, title ){\n    return md5 ( url + title );\n}*/\n\nfunction indexBm(id, bookmark){\n    let bm = bmNodeToBm(bookmark);\n    let bmMap = new Map();\n    bmMap.set(bm.id,bm);\n    _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].index(bmMap);\n}\n\nfunction disindexBm(id, info){\n    let bmId = id;\n    _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].disindex(bmId);\n}\n\nfunction bmNodeToBm( bmNode ){\n    return {\n\t\"title\": bmNode.title,\n\t\"url\": bmNode.url,\n\t\"date\": bmNode.dateAdded,\n\t\"id\": bmNode.id\t\n    }\n}\n\n\n//# sourceURL=webpack:///./src/bookmarks.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stringUtils.js */ \"./src/stringUtils.js\");\n/* harmony import */ var _storageDao_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storageDao.js */ \"./src/storageDao.js\");\n\n\n\n//var index = new Map();\n//var bmMap = new Map();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    index : indexBms,\n    /*\n      Get array of bookmark ids from an index token of array of tokens\n     */\n    getBMId : getBookmarkIds,\n    /*\n      Get array of bookmarks from a bookmark id or array of ids\n     */\n    getBM : getBookmarks,\n    disindex : async function ( BMId ) {\n\n\tlet hasBm = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"bookmarks\", BMId);\n\tif ( hasBm === true ){\n\t    _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].del(\"bookmarks\", BMId);\n\t}\n\tlet indexArray = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getAll(\"index\"); //TODO\n\t//console.log(indexArray);\n\tfor ( let indexItem of indexArray ) {\n\t    let i = indexItem.val.indexOf(BMId);\n\t    if (  i !== -1 ){\n\t\tindexItem.val = indexItem.val.splice ( i, 1 );\n\t\tif ( indexItem.val.lenth > 0){\n\t\t    _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"index\", indexItem.id, indexItem.val);\n\t\t}\n\t\telse{\n\t\t    _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].del(\"index\", indexItem.id );\n\t\t}\n\t    }\n\t}\n\t\n\t/*if ( bmMap.has(BMId)){\n\t    //1. remove from bookmark map\n\t    bmMap.delete(BMId);\n\n\t    //2. remove from index\n\t    index.forEach(function(v,k){\n\t\tlet i = v.indexOf(BMId);\n\t\tif ( i !== -1  ){\n\t\t    v = v.splice(i, 1);\n\t\t    if ( v.length > 0 ){\n\t\t\tindex.set(k,v);\n\t\t    }\n\t\t    else{\n\t\t\tindex.delete(k);\n\t\t    }\n\t\t}\n\t    });\n\t}*/\n    }\n});\n\nasync function indexBms( bookmarks ){\n    bookmarks.forEach(async function (v,k ){\n\tlet hasBm = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"bookmarks\", k);\n\t\n\tif ( hasBm === false ){\n\t    await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"bookmarks\", k, v);\n\t    let prefixedIndexes = [];\n\t    prefixedIndexes = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toIndexable(v.title);\n\t    prefixedIndexes = prefixedIndexes.concat(_stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].urlToIndexable(v.url));\n\t    prefixedIndexes = Array.from(new Set(prefixedIndexes)); //remove dupes\n\t    for ( let t of prefixedIndexes ) {\n\t\tlet hasToken = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"index\",t);\n\t\tif ( hasToken == true ){\n\t\t    let ids = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"index\", t);\n\t\t    ids.push(k);\n\t\t    await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"index\", t, ids);\n\t\t}\n\t\telse{\n\t\t    let keyArray = [\"\"+k];\n\t\t    await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(\"index\", t, keyArray);\n\t\t}\n\t    }\n\t}\n    });\n}\n\t\t     \n\nasync function getBookmarkIds ( key ){\n    let result = [];\n    if ( key.constructor === Array ){\n\tfor ( const k of key ){\n\t    let hasToken = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"index\", k);\n\t    if( hasToken === true ){\n\t\tlet ids = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"index\", k);\n\t\tresult = result.concat(ids);\n\t    }\n\t}\n    }\n    else{\n\tlet hasToken = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"index\", k);\n\tif ( hasToken === true ){\n\t    let ids = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"index\", k);\n\t    result = result.concat(ids);\n\t}\n    }\n    return result;\n }\nasync function getBookmarks ( BMId ) {\n    let result = [];\n    if( BMId.constructor === Array ){\n\tfor ( const id of BMId ) {\n\t    let hasBm = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"bookmarks\",id);\n\t    if( hasBm === true ){\n\t\tlet bms = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"bookmarks\", id);\n\t\tresult.push(bms)\n\t    }\n\t}\n    }\n    else{\n\tlet hasBm = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].has(\"bookmarks\", BMId);\n\tif ( hasBm === true ){\n\t    let bm = await _storageDao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"bookmarks\", BMId);\n\t    result.push(bm);\n\t}\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bookmarks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bookmarks.js */ \"./src/bookmarks.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/* harmony import */ var _omnibox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./omnibox.js */ \"./src/omnibox.js\");\n/* harmony import */ var _storageDao_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storageDao.js */ \"./src/storageDao.js\");\n\n\n\n\n\n//1. setup stuf on install\n\nbrowser.runtime.onInstalled.addListener(loadBms);\n\n//2. init omnibox\n_omnibox_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].init();\n\n//3. init bookmark handlers\n_bookmarks_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].init();\n\n//4. clear storage\n_storageDao_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].init();\n\nfunction loadBms(){\n    _bookmarks_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAll().then(\n\tfunction(bms){\n\t    //1 : index bms\n\t    _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].index(bms);//.then(res=>storage.getAll(\"test\",\"test\"));\n\n\n\t}\n    );    \n}\n\n\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/omnibox.js":
/*!************************!*\
  !*** ./src/omnibox.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _search_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./search.js */ \"./src/search.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    init : function (){\n\tbrowser.omnibox.onInputChanged.addListener(srcInputListener);\n\tbrowser.omnibox.onInputEntered.addListener(inputEntered);\n\tbrowser.omnibox.setDefaultSuggestion(\n\t    { \"description\": \"CHOP CHOP'S SEARCH SEARCH - type at least 3 characters\" }\n\t);\n    }\n\n});\n\nfunction inputEntered(url, disposition){\n    switch (disposition) {\n    case \"currentTab\":\n\tbrowser.tabs.update({url});\n\tbreak;\n    case \"newForegroundTab\":\n\tbrowser.tabs.create({url});\n\tbreak;\n    case \"newBackgroundTab\":\n\tbrowser.tabs.create({url, active: false});\n\tbreak;\n    }\n}\nfunction emptySuggestion(){\n    return {\n\t\"content\": \"\",\n\t\"description\": \"Sry, no results. Please type at lest 3 characters.\"\n    }\n}\nfunction srcInputListener(text, suggest){\n    console.log ( \"searching for query : \"+text);\n    if ( text.length < 3 ) {\n\tsuggest(emptySuggestion());\n\treturn ;\n    }\n    _search_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].queryToBookmarks(text).then(function(results){\n\tlet suggestions = results.map(function (bm) {\n\t    return {\n\t\t\"content\": bm.url,\n\t\t\"description\": bm.title\n\t    };\n\t});\n\tif( suggestions.length === 0 ){\n\t    suggest(emptySuggestion());\n\t    return;\n\t}\n\tsuggest(suggestions);\n    });\n}\n\n\n//# sourceURL=webpack:///./src/omnibox.js?");

/***/ }),

/***/ "./src/search.js":
/*!***********************!*\
  !*** ./src/search.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stringUtils.js */ \"./src/stringUtils.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n\n\n\nvar levenshteinTreshold = 0.65;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    queryToBookmarks: async function( query ){\n\tlet srcIndices = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toSearchable(query);\n\tlet bmIds = await _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getBMId(srcIndices);\n\tconsole.log(\"bm ids\");\n\tconsole.log(bmIds);\n\tlet bookmarks = await _index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getBM(bmIds);\n\tbookmarks = Array.from(new Set(bookmarks));\n\tbookmarks = sortBookmarks(bookmarks, query);\n\treturn bookmarks;\n\t/*let srcIndices = stringUtils.toSearchable(query);\n\tindex.getBMId(srcIndices).then(bmIds=>{\n\t    console.log(\"bm ids\");\n\t    console.log(bmIds);\n\t    let bookmarks = await index.getBM(bmIds);\n\t    bookmarks = Array.from(new Set(bookmarks));\n\t    bookmarks = sortBookmarks(bookmarks, query);\n\t    return bookmarks;\n\t});*//*\n\tlet bookmarks = index.getBM(bmIds);\n\tbookmarks = Array.from(new Set(bookmarks));\n\tbookmarks = sortBookmarks(bookmarks, query);\n\treturn bookmarks;*/\n    }\n});\n\nfunction sortBookmarks(bookmarkResults, query){\n    let compQuery = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toComparable(query);\n    let scoredBookmarks = [];\n    bookmarkResults.forEach(function (bookmark){\n\tlet compBm = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toComparable(bookmark.title);\n\tlet hitScore = 0;\n\tfor ( let tk of compQuery){\n\t    for (let bt of compBm ){\n\t\tlet gScore = _stringUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].levenshtein(tk,bt);\n\t\tif ( gScore >= levenshteinTreshold ) {\n\t\t    hitScore ++;\n\t\t}\n\t    }\n\t}\n\tscoredBookmarks.push(\n\t    {\n\t\t\"score\": hitScore,\n\t\t\"item\": bookmark\n\t    }\n\t);\n    });\n    scoredBookmarks = scoredBookmarks.filter(r => r.score > 0);\n    scoredBookmarks.sort(compareScoredBookmarks);\n    console.log(\"scored bookmarks\");\n    console.log(scoredBookmarks);\n    let result = scoredBookmarks.map(function ( sb ){\n\treturn sb.item;\n    });\n    return result;\n}\n\n\nfunction compareScoredBookmarks(scoredBmA, scoredBmB ){\n    //sort by score, then by most recent\n    if ( scoredBmA.score > scoredBmB.score ){\n\treturn -1;\n    }\n    else if ( scoredBmA.score < scoredBmB.score ){\n\treturn 1;\n    }\n    else if ( scoredBmA.score === scoredBmB.score ){\n\tif ( scoredBmA.date > scoredBmB.date ){\n\t    return -1;\n\t}\n\telse{\n\t    return 1;\n\t}\n    }\n    else{\n\treturn 0;\n    }\n\t\n}\n\n\n//# sourceURL=webpack:///./src/search.js?");

/***/ }),

/***/ "./src/storageDao.js":
/*!***************************!*\
  !*** ./src/storageDao.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*\n  Store and retrieve stuff in extension localstorage\n*/\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    set: store,\n    get: retrieve,\n    del: remove,\n    init: setup, //TODO: delete if no need for this\n    has: contains,\n    getAll: findAll\n});\n\nasync function store( type, key, val){\n    let k = String.raw`${type}.${key}`;\n    let data = {};\n    data[k] = val;\n    await browser.storage.local.set(data);\n}\nasync function retrieve ( type, key){\n    let k = `${type}.${key}`;\n    let res = await browser.storage.local.get(k);\n    return res[k];\n}\nfunction remove ( type, key){\n    browser.storage.local.remove(`${type}.${key}`);\n}\nfunction setup(){\n    browser.storage.local.clear();//returns promise\n}\nasync function contains(type, key){\n    let res = await browser.storage.local.get(`${type}.${key}`);\n    return !( Object.keys(res).length === 0 && res.constructor === Object);\n}\nasync function findAll(type){\n    let allStoredObjects = await browser.storage.local.get();\n    //res = res.filter()\n    let resultArray = [];\n    for ( let key in allStoredObjects ){\n\tif ( allStoredObjects.hasOwnProperty(key)){\n\t    if ( key.startsWith(type)){\n\t\tlet obj = {};\n\t\tobj.id = key;\n\t\tobj.val = allStoredObjects[key];\n\t\tresultArray.push( obj );\n\t    }\n\t}\n    }\n    \n    //console.log(\"find all : \");\n    //console.log(resultArray);\n    return resultArray;\n}\n\n\n//# sourceURL=webpack:///./src/storageDao.js?");

/***/ }),

/***/ "./src/stringUtils.js":
/*!****************************!*\
  !*** ./src/stringUtils.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fast_levenshtein__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-levenshtein */ \"./node_modules/fast-levenshtein/levenshtein.js\");\n/* harmony import */ var fast_levenshtein__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_levenshtein__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var double_metaphone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-metaphone */ \"./node_modules/double-metaphone/index.js\");\n/* harmony import */ var double_metaphone__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(double_metaphone__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  String manipulation stuff\n*/\n\n\n\n// radix tree min str length\nvar rTreeMinLength = 2;\nvar kwMinLength = 4;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    toLowerCase : lowerCase,\n    tokenize : tokenizer,\n    filterEmptyString : isNotEmpty,\n    rTree : radixTree,\n    levenshtein: gld,\n    // tokenize, metaphone, remove dupes\n    toSearchable : function ( query ){\n\tlet tokenized = lcTokenizeFilter(query);\n\tlet metaphoned = [];\n\ttokenized.forEach(function (token){\n\t    metaphoned = metaphoned.concat(double_metaphone__WEBPACK_IMPORTED_MODULE_1___default()(token));\n\t});\n\tlet result = Array.from(new Set(metaphoned));\n\treturn result;\n    },\n    toComparable : function (text){\n\tlet tokenized = lcTokenizeFilter(text);\n\tlet result = Array.from(new Set(tokenized));\n\treturn result;\n    },\n    toIndexable : function (str){\n\tlet tokenArray = lcTokenizeFilter(str);\n\tlet metaphoned = [];\n\ttokenArray.forEach(function(token){\n\t    metaphoned = metaphoned.concat(double_metaphone__WEBPACK_IMPORTED_MODULE_1___default()(token));\n\t});\n\tmetaphoned = Array.from(new Set(metaphoned));\n\tlet prefixedIndexes = [];\n\tmetaphoned.forEach(function(mtp){\n\t    prefixedIndexes = prefixedIndexes.concat(radixTree(mtp));\n\t});\n\tprefixedIndexes = Array.from(new Set(prefixedIndexes));\n\treturn prefixedIndexes;\n    },\n    urlToIndexable : urlToTokens\n});\n\n\nfunction radixTree ( str ) {\n    if ( str.length <= rTreeMinLength ){\n        return [str];\n    }\n    else{\n        let result = [];\n        for ( let i = rTreeMinLength ; i <= str.length ; i++ ){\n\t    result.push(str.substr(0, i));\n        }\n\treturn result;\n    }\n}\nfunction lowerCase( str ){\n    return str.toLowerCase();\n}\nfunction tokenizer( str ){\n    return str.split(/[\\W_]/);\n}\nfunction isNotEmpty( str ) {\n    return str !== \"\";\n}\nfunction tokenIsBigEnough(str){\n    return str.length >= kwMinLength;\n}\n/*\n  Generalized levenshtein dist \n  Returns double in [0,1]\n*/\nfunction gld (stra, strb){\n    let ld = fast_levenshtein__WEBPACK_IMPORTED_MODULE_0___default.a.get ( stra, strb );\n    let result = 1 - ((2 * ld) / (stra.length + strb.length + ld ));\n    return result;\n}\n//convenience function\nfunction lcTokenizeFilter(str){\n    return tokenizer(lowerCase(str)).filter(isNotEmpty);\n}\n\nfunction urlToTokens ( urlStr ) {\n    let url = new URL(lowerCase(urlStr));\n    let domain = url.hostname;\n    let path = url.pathname;\n    let tokens = tokenizer ( domain );\n    tokens =tokens.concat( tokenizer (path ));\n    tokens = tokens.filter(tokenIsBigEnough);\n\n    let metaphoned = [];\n    tokens.forEach(function(token){\n\tmetaphoned = metaphoned.concat(double_metaphone__WEBPACK_IMPORTED_MODULE_1___default()(token));\n    });\n    metaphoned = Array.from(new Set(metaphoned));\n    let prefixedIndexes = [];\n    metaphoned.forEach(function(mtp){\n\tprefixedIndexes = prefixedIndexes.concat(radixTree(mtp));\n    });\n    prefixedIndexes = Array.from(new Set(prefixedIndexes));\n    return prefixedIndexes;\n}\n\n\n//# sourceURL=webpack:///./src/stringUtils.js?");

/***/ })

/******/ });